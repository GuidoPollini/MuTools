
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Red9_Meta &mdash; Red9 v2.0 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Red9 v2.0 documentation" href="../index.html" />
    <link rel="next" title="Red9_PoseSaver" href="Red9_PoseSaver.html" />
    <link rel="prev" title="Red9_General" href="Red9_General.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Red9_PoseSaver.html" title="Red9_PoseSaver"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Red9_General.html" title="Red9_General"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Red9 v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="red9-meta">
<h1>Red9_Meta<a class="headerlink" href="#red9-meta" title="Permalink to this headline">¶</a></h1>
<p>Red9 Meta is a full metaData API that deals with Maya nodes in a more seemless manor. I&#8217;ve
tried to do as much documentation as I can both in terms of commenting the code and doing
examples and Vimeo demos.</p>
<p>This is a big concept and I&#8217;ll be expanding these docs accordingly when I get more time.</p>
<div class="section" id="vimeo-demos">
<h2>Vimeo Demos:<a class="headerlink" href="#vimeo-demos" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video1 &lt;<a class="reference external" href="https://vimeo.com/100882408">https://vimeo.com/100882408</a>&gt;</li>
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video2 &lt;<a class="reference external" href="https://vimeo.com/100883383">https://vimeo.com/100883383</a>&gt;</li>
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video3 &lt;<a class="reference external" href="https://vimeo.com/102463373">https://vimeo.com/102463373</a>&gt;</li>
<li>MetaData part1 &lt;<a class="reference external" href="https://vimeo.com/61841345">https://vimeo.com/61841345</a>&gt;</li>
<li>MetaData part2 &lt;<a class="reference external" href="https://vimeo.com/62546103">https://vimeo.com/62546103</a>&gt;</li>
<li>MetaData Part3 &lt;<a class="reference external" href="https://vimeo.com/64258996">https://vimeo.com/64258996</a>&gt;</li>
<li>MetaData part4 &lt;<a class="reference external" href="https://vimeo.com/72006183">https://vimeo.com/72006183</a>&gt;</li>
<li>MetaData MetaHUD &lt;<a class="reference external" href="https://vimeo.com/65006622">https://vimeo.com/65006622</a>&gt;</li>
</ul>
<p>There are also some basic examples in the Red9 Package itself found under the examples folder.</p>
<span class="target" id="module-Red9.core.Red9_Meta"></span><div class="section" id="basic-metaclass-use">
<h3>Basic MetaClass Use:<a class="headerlink" href="#basic-metaclass-use" title="Permalink to this headline">¶</a></h3>
<p>Now moved to the examples folder for more detailed explanations</p>
<ul class="simple">
<li><em>Red9/examples/MetaData_Getting_started.py</em></li>
<li><em>Red9/examples/MetaRig_Morpheus.py</em></li>
</ul>
<p>Also see the unittesting folder to see what the code can do and
what each function is expected to return</p>
<ul class="simple">
<li><em>Red9/tests</em></li>
</ul>
<p class="rubric">Key Functions</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.registerMClassInheritanceMapping" title="Red9.core.Red9_Meta.registerMClassInheritanceMapping"><tt class="xref py py-obj docutils literal"><span class="pre">registerMClassInheritanceMapping</span></tt></a>()</td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.registerMClassNodeMapping" title="Red9.core.Red9_Meta.registerMClassNodeMapping"><tt class="xref py py-obj docutils literal"><span class="pre">registerMClassNodeMapping</span></tt></a>([nodeTypes])</td>
<td>Hook to allow you to extend the type of nodes included in all the</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.isMetaNode" title="Red9.core.Red9_Meta.isMetaNode"><tt class="xref py py-obj docutils literal"><span class="pre">isMetaNode</span></tt></a>(node[,&nbsp;mTypes,&nbsp;checkInstance,&nbsp;...])</td>
<td>Simple bool, Maya Node is or isn&#8217;t an mNode</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.isMetaNodeInherited" title="Red9.core.Red9_Meta.isMetaNodeInherited"><tt class="xref py py-obj docutils literal"><span class="pre">isMetaNodeInherited</span></tt></a>(node[,&nbsp;mInstances])</td>
<td>unlike isMetaNode which checks the node against a particular MetaClass,</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.getMetaNodes" title="Red9.core.Red9_Meta.getMetaNodes"><tt class="xref py py-obj docutils literal"><span class="pre">getMetaNodes</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Get all mClass nodes in scene and return as mClass objects if possible</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.getConnectedMetaNodes" title="Red9.core.Red9_Meta.getConnectedMetaNodes"><tt class="xref py py-obj docutils literal"><span class="pre">getConnectedMetaNodes</span></tt></a>(*args,&nbsp;**kws)</td>
<td>From a given set of Maya Nodes return all connected mNodes</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.getConnectedMetaSystemRoot" title="Red9.core.Red9_Meta.getConnectedMetaSystemRoot"><tt class="xref py py-obj docutils literal"><span class="pre">getConnectedMetaSystemRoot</span></tt></a>(node,&nbsp;**kws[,&nbsp;...])</td>
<td>From a given node see if it&#8217;s part of a MetaData system, if so</td>
</tr>
</tbody>
</table>
<p class="rubric">Main Classes</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><tt class="xref py py-obj docutils literal"><span class="pre">MetaClass</span></tt></a>(*args,&nbsp;**kws[,&nbsp;node,&nbsp;name,&nbsp;...])</td>
<td>Base Class for Meta support. This manages all the attribute and class</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><tt class="xref py py-obj docutils literal"><span class="pre">MetaRig</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Sub-class of Meta used as the back-bone of our internal rigging</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRigSubSystem" title="Red9.core.Red9_Meta.MetaRigSubSystem"><tt class="xref py py-obj docutils literal"><span class="pre">MetaRigSubSystem</span></tt></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MRig, designed to organize Rig sub-systems (ie L_ArmSystem, L_LegSystem..)</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRigSupport" title="Red9.core.Red9_Meta.MetaRigSupport"><tt class="xref py py-obj docutils literal"><span class="pre">MetaRigSupport</span></tt></a>(*args,&nbsp;**kws)</td>
<td>SubClass of MetaClass, designed to organize support nodes, solvers and other internal</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaFacialRig" title="Red9.core.Red9_Meta.MetaFacialRig"><tt class="xref py py-obj docutils literal"><span class="pre">MetaFacialRig</span></tt></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaRig, designed to be manage Facial systems in the MetaData</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaFacialRigSupport" title="Red9.core.Red9_Meta.MetaFacialRigSupport"><tt class="xref py py-obj docutils literal"><span class="pre">MetaFacialRigSupport</span></tt></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaClass, designed to organize support nodes, solvers and other internal</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode" title="Red9.core.Red9_Meta.MetaHIKCharacterNode"><tt class="xref py py-obj docutils literal"><span class="pre">MetaHIKCharacterNode</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Casting HIK directly to a metaClass so it&#8217;s treated as meta by default.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode" title="Red9.core.Red9_Meta.MetaHIKControlSetNode"><tt class="xref py py-obj docutils literal"><span class="pre">MetaHIKControlSetNode</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Casting HIK directly to a metaClass so it&#8217;s treated as meta by default.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHUDNode" title="Red9.core.Red9_Meta.MetaHUDNode"><tt class="xref py py-obj docutils literal"><span class="pre">MetaHUDNode</span></tt></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaClass, designed as a simple interface</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaTimeCodeHUD" title="Red9.core.Red9_Meta.MetaTimeCodeHUD"><tt class="xref py py-obj docutils literal"><span class="pre">MetaTimeCodeHUD</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Generate&#8217;s a HUD node connected to the main timecode attrs,</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassInheritanceMapping">
<tt class="descname">registerMClassInheritanceMapping</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassInheritanceMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printSubClassRegistry">
<tt class="descname">printSubClassRegistry</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.printSubClassRegistry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassMetaRegistry">
<tt class="descname">getMClassMetaRegistry</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassMetaRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper to return the Registry from the global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassInstances">
<tt class="descname">getMClassInstances</tt><big>(</big><em>mInstances</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of Registered metaClasses that are subclassed from the given
classes. This is so in code/UI&#8217;s you can group metaClasses by their
inheritance . . . ie, give me all export metaClasses that are registered</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mInstanes</strong> &#8211; given metaClass to test inheritance - cls or [cls]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.mTypesToRegistryKey">
<tt class="descname">mTypesToRegistryKey</tt><big>(</big><em>mTypes</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.mTypesToRegistryKey" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure we&#8217;re dealing with a list of class keys to process
against the registry. Allows us to pass in str &#8216;MetaRig&#8217; or
r9Meta.MetaRig to the args for type checking</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassDataFromNode">
<tt class="descname">getMClassDataFromNode</tt><big>(</big><em>node</em>, <em>checkInstance=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassDataFromNode" title="Permalink to this definition">¶</a></dt>
<dd><p>from the node get the class to instantiate, this gives us a level of
flexibility over mClass attr rather than pure hard coding as it was previously</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; node to retrieve the mClass binding from</li>
<li><strong>checkInstance</strong> &#8211; bool, specify whether to test the given node as a per existing instance
this check is purely for speed internally so we don&#8217;t check the same thing over and over again</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassNodeMapping">
<tt class="descname">registerMClassNodeMapping</tt><big>(</big><em>nodeTypes=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassNodeMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to allow you to extend the type of nodes included in all the
getMeta searches. Allows you to expand into using nodes of any type
as metaNodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodeTypes</strong> &#8211; allows you to expand metaData and use any nodeType
default is always &#8216;network&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this now validates &#8216;nodeTypes&#8217; against Maya registered nodeTypes before being
allowed into the registry. Why, well lets say you have a new nodeType from a
plugin but that plugin isn&#8217;t currently loaded, this now stops that type being
generically added by any custom boot sequence.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printMetaTypeRegistry">
<tt class="descname">printMetaTypeRegistry</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.printMetaTypeRegistry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassNodeTypes">
<tt class="descname">getMClassNodeTypes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper for all nodeTypes registered in the Meta_NodeType global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetMClassNodeTypes">
<tt class="descname">resetMClassNodeTypes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.resetMClassNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.generateUUID">
<tt class="descname">generateUUID</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.generateUUID" title="Permalink to this definition">¶</a></dt>
<dd><p>unique UUID used by the caching system</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassNodeCache">
<tt class="descname">registerMClassNodeCache</tt><big>(</big><em>mNode</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassNodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a given mNode to the global RED9_META_NODECACHE cache of currently instantiated 
MetaNode objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mNode</strong> &#8211; instantiated mNode to add</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaFromCache">
<tt class="descname">getMetaFromCache</tt><big>(</big><em>mNode</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaFromCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull the given mNode from the RED9_META_NODECACHE if it&#8217;s
already be instantiated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mNode</strong> &#8211; str(name) of node from DAG</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.upgrade_toLatestBindings">
<tt class="descname">upgrade_toLatestBindings</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.upgrade_toLatestBindings" title="Permalink to this definition">¶</a></dt>
<dd><p>take a current scene and upgrade all the mNodes to include any new
binding attrs that the base class may have been upgraded to use.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printMetaCacheRegistry">
<tt class="descname">printMetaCacheRegistry</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.printMetaCacheRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>print the current VALID Cache of instantiated MetaNodes 
Note that we call a cleanCache before printing to remove any 
currently invalid MObjects from the Cache.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.cleanCache">
<tt class="descname">cleanCache</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.cleanCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Run through the current cache of metaNodes and confirm that they&#8217;re 
all still valid by testing the MObjectHandles.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.removeFromCache">
<tt class="descname">removeFromCache</tt><big>(</big><em>mNodes</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.removeFromCache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetCache">
<tt class="descname">resetCache</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.resetCache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetCacheOnSceneNew">
<tt class="descname">resetCacheOnSceneNew</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.resetCacheOnSceneNew" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassNodeCache">
<tt class="descname">getMClassNodeCache</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassNodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper for all nodeTypes registered in the Meta_NodeType global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMObject">
<tt class="descname">getMObject</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>base wrapper to get the MObject from node</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.nodeLockManager">
<tt class="descname">nodeLockManager</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.nodeLockManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple decorator to manage metaNodes which are locked. Why lock??
Currently just the metaRig and therefore any subclasses of that are locked.
The reason is that the Maya &#8216;network&#8217; node I use has issues when certain
connections are deleted, the node itself can get deleted and cleanup, removing
the entire network! Try it, make a metaNode and key an attr on it, then run
cutKeys...the node will be deleted.</p>
<p>This decorator is used to manage the unlocking of self for all calls that
require change access rights to the &#8216;network&#8217; node itself.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.pymelHandler">
<tt class="descname">pymelHandler</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.pymelHandler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.attributeDataType">
<tt class="descname">attributeDataType</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.attributeDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the attribute type for all the cmds handling</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNode">
<tt class="descname">isMetaNode</tt><big>(</big><em>node</em>, <em>mTypes=</em><span class="optional">[</span><span class="optional">]</span>, <em>checkInstance=True</em>, <em>returnMClass=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple bool, Maya Node is or isn&#8217;t an mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya node to test</li>
<li><strong>mTypes</strong> &#8211; only match given MetaClass&#8217;s - str or class accepted</li>
<li><strong>checkInstance</strong> &#8211; bool, used only internally for optimisation</li>
<li><strong>returnMClass</strong> &#8211; if True return the str(mClass) that this node is bound too</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this does not instantiate the mClass to query it like the
isMetaNodeInherited which has to figure the subclass mapping</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNodeInherited">
<tt class="descname">isMetaNodeInherited</tt><big>(</big><em>node</em>, <em>mInstances=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNodeInherited" title="Permalink to this definition">¶</a></dt>
<dd><p>unlike isMetaNode which checks the node against a particular MetaClass,
this expands the check to see if the node is inherited from or a subclass of
a given Meta base class, ie, part of a system
TODO : we COULD return the instantiated metaClass object here rather than just a bool??</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNodeClassGrp">
<tt class="descname">isMetaNodeClassGrp</tt><big>(</big><em>node</em>, <em>mClassGrps=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNodeClassGrp" title="Permalink to this definition">¶</a></dt>
<dd><p>check the mClassGrp attr to see if it matches the given</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaNodes">
<tt class="descname">getMetaNodes</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all mClass nodes in scene and return as mClass objects if possible
:param mTypes: only return meta nodes of a given type
:param mInstances: idea - this will check subclass inheritance, ie, MetaRig would</p>
<blockquote>
return ALL nodes who&#8217;s class is inherited from MetaRig. Allows you to
group the data more efficiently by base classes and their inheritance</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mClassGrps</strong> &#8211; checks the mClassGrp used to soft grp nodes and mark ones as a certain
system type without looking at class inheritance. Good for marking key classes as bases</li>
<li><strong>mAttrs</strong> &#8211; uses the FilterNode.lsSearchAttributes call to match nodes via given attrs</li>
<li><strong>dataType</strong> &#8211; default=&#8217;mClass&#8217; return the nodes already instantiated to
the correct class object. If not then return the Maya node itself</li>
<li><strong>nTypes</strong> &#8211; only inspect nodes of a given Type</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaRigs">
<tt class="descname">getMetaRigs</tt><big>(</big><em>mInstances='MetaRig'</em>, <em>mClassGrps=</em><span class="optional">[</span>, <em>'MetaRig'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaRigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper over the get call to fire back specifically MetaRigs.
We use mInstances rather than mTypes directly for MetaRig to 
cope with people subclassing, then we clamp the search to the Root MetaRig
using the mClassGrps variable. This probably will expand as it&#8217;s tested</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getUnregisteredMetaNodes">
<tt class="descname">getUnregisteredMetaNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getUnregisteredMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspect all nodes for the mClass attrs, then see if those nodes and mClass
types are currently registered in the systems. This means you can inspect
files from others who have bespoke MClass&#8217;s and still see their node structures
even though you won&#8217;t be able to use or return their class objects</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getConnectedMetaNodes">
<tt class="descname">getConnectedMetaNodes</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getConnectedMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>From a given set of Maya Nodes return all connected mNodes
Default return is mClass objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to inspect for connected meta data, note these are cmds MAYA nodes</li>
<li><strong>source</strong> &#8211; <cite>bool</cite> clamp the search to the source side of the graph</li>
<li><strong>destination</strong> &#8211; <cite>bool</cite> clamp the search to the destination side of the graph</li>
<li><strong>mTypes</strong> &#8211; return only given MetaClass&#8217;s</li>
<li><strong>mInstances</strong> &#8211; this will check subclass inheritance, ie, &#8216;MetaRig&#8217; would
return ALL nodes who&#8217;s class is inherited from MetaRig. Allows you to
group the data more efficiently by base classes and their inheritance</li>
<li><strong>mAttrs</strong> &#8211; uses the FilterNode.lsSearchAttributes call to match nodes via given attrs</li>
<li><strong>dataType</strong> &#8211; default=&#8217;mClass&#8217; return the nodes already instantiated to
the correct class object. If not then return the Maya node</li>
<li><strong>nTypes</strong> &#8211; only return nodes of a given type, note this type must be registered to meta!</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getConnectedMetaSystemRoot">
<tt class="descname">getConnectedMetaSystemRoot</tt><big>(</big><em>node</em>, <em>mTypes=</em><span class="optional">[</span><span class="optional">]</span>, <em>ignoreTypes=</em><span class="optional">[</span><span class="optional">]</span>, <em>mSystemRoot=True</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.getConnectedMetaSystemRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>From a given node see if it&#8217;s part of a MetaData system, if so
walk up the parent tree till you get to top meta node and return the class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ignoreTypes</strong> &#8211; if the given mClass node types are found to be systemRoots ignore them
why, lets say we have a system with several mNodes that are technically the head of the 
system and you need to skip a given type.</li>
<li><strong>mTypes</strong> &#8211; like the rest of Meta, if you give it a specific mType to find as root it will do 
just that if that node is a root node in the system.</li>
<li><strong>mSystemRoot</strong> &#8211; whether to respect the mSystemRoot abort bool on the nodes, default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this walks upstream only from the given node, so if you effectively have multiple root nodes
in the system but wired to different parts of the network, and when walking upstream from the given
you only get to one of ththose because of the network wiring, then that is correct.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.convertMClassType">
<tt class="descname">convertMClassType</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.convertMClassType" title="Permalink to this definition">¶</a></dt>
<dd><p>change the current mClass type of the given class instance. This used to be
an internal func in eth baseClass but that seemed to make no sense as 
you&#8217;re mutating the class dynamically</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cls</strong> &#8211; initialize mClass object t9o mutate</li>
<li><strong>newMClass</strong> &#8211; new class definition for the given cls</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>..note ::</dt>
<dd>If you&#8217;re converting a StandardWrapped Maya node to a fully fledged mNode then you also
need to ensure that that NODETYPE is registered to meta or else it won&#8217;t get picked up
when you run any of the gets.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.convertNodeToMetaData">
<tt class="descname">convertNodeToMetaData</tt><big>(</big><em>nodes</em>, <em>mClass</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.convertNodeToMetaData" title="Permalink to this definition">¶</a></dt>
<dd><p>pass in a node and convert it to a MetaNode, assuming that the nodeType
is valid in the metaNodeTypesRegistry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to cast to mClass instances</li>
<li><strong>mClass</strong> &#8211; mClass class to convert them too</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>..note ::</dt>
<dd>ideally you should use the convertMClassType func now as that wraps this if the
nodes passed in aren&#8217;t already instanitated or bound to meta</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MClassNodeUI">
<em class="property">class </em><tt class="descname">MClassNodeUI</tt><big>(</big><em>mTypes=None</em>, <em>mInstances=None</em>, <em>mClassGrp=None</em>, <em>closeOnSelect=False</em>, <em>funcOnSelection=None</em>, <em>sortBy='byClass'</em>, <em>allowMulti=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple UI to display all MetaNodes in the scene</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mTypes</strong> &#8211; MetaNode class to search and display &#8216;MetaRig&#8217;</li>
<li><strong>mInstances</strong> &#8211; MetaNode inheritance map, ie show all subclass of mType..</li>
<li><strong>closeOnSelect</strong> &#8211; on text select close the UI</li>
<li><strong>funcOnSelection</strong> &#8211; function to run where the selected mNode is expected
as first arg, ie funcOnSelection=cmd.select so that when run the item is
selected in the UI cmds.select(item) is run. Basically used as a dynamic callback</li>
<li><strong>sortBy</strong> &#8211; Sort the nodes found &#8216;byClass&#8217; or &#8216;byName&#8217;</li>
<li><strong>allowMulti</strong> &#8211; allow multiple selection in the UI</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.show">
<em class="property">classmethod </em><tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.fitTextScrollFucker">
<tt class="descname">fitTextScrollFucker</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.fitTextScrollFucker" title="Permalink to this definition">¶</a></dt>
<dd><p>bodge to resize tghe textScroll as the default Maya control is SHITE!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.graphNetwork">
<tt class="descname">graphNetwork</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.graphNetwork" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.selectCmd">
<tt class="descname">selectCmd</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.selectCmd" title="Permalink to this definition">¶</a></dt>
<dd><p>callback run on select in the UI, allows you to run the func passed
in by the funcOnSelection arg</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.deleteCall">
<tt class="descname">deleteCall</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.deleteCall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.doubleClick">
<tt class="descname">doubleClick</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.doubleClick" title="Permalink to this definition">¶</a></dt>
<dd><p>run the generic meta.getChildren call and select the results</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.fillScroll">
<tt class="descname">fillScroll</tt><big>(</big><em>sortBy=None</em>, <em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.fillScroll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printRegisteredNodeTypes">
<tt class="descname">printRegisteredNodeTypes</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printRegisteredNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printRegisteredMetaClasses">
<tt class="descname">printRegisteredMetaClasses</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printRegisteredMetaClasses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printMetaNodeCache">
<tt class="descname">printMetaNodeCache</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printMetaNodeCache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaClass">
<em class="property">class </em><tt class="descname">MetaClass</tt><big>(</big><em>node=None</em>, <em>name=None</em>, <em>nodeType='network'</em>, <em>autofill='all'</em>, <em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base Class for Meta support. This manages all the attribute and class 
management for all subsequent inherited classes. This is the core of
the MetaData factory API</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya Node - if given we test it for the mClass attribute, if it exists 
we initialize a class of that type and return. If not passed in then we 
make a new network node for the type given.</li>
<li><strong>name</strong> &#8211; only used on create, name to set for the new Maya Node (self.mNode)</li>
<li><strong>nodeType</strong> &#8211; allows you to specify a node of type to create as a new mClass node. 
default is &#8216;network&#8217;, not that for any node to show up in the get 
calls that type MUST be registered in the RED9_META_NODETYPE_REGISTERY</li>
<li><strong>autofill</strong> &#8211; &#8216;str&#8217; cast all the MayaNode attrs into the class dict by default. 
Updated: modes: &#8216;all&#8217; or &#8216;messageOnly&#8217;. all casts every attr, messageOnly 
fills the node with just message linked attrs (designed for MetaClass work 
with HIK characterNode)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mNode is now a wrap on the MObject so will always be in sync even if the node is renamed/parented</p>
</div>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>a metaNode in this case is valid if it has connections, if not it&#8217;s classed invalid</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isValidMObject">
<tt class="descname">isValidMObject</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isValidMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the MObject, without this Maya will crash if the pointer is no longer valid
TODO: thinking of storing the dagPath when we fill in the mNode to start with and
if this test fails, ie the scene has been reloaded, then use the dagPath to refind
and refil the mNode property back in.... maybe??</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isSystemRoot">
<tt class="descname">isSystemRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isSystemRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>used by the getConnectedMetaSystemRoot call to identify if this
node is a top system node. Having his as an attr allows us to designate
certain subsystems as root nodes in their own right. Ie, Facial controlBoard</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNode">
<tt class="descname">mNode</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNode" title="Permalink to this definition">¶</a></dt>
<dd><p>mNode is the pointer to the Maya object itself, retrieved via the MObject
under the hood so it&#8217;s always in sync.</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNodeID">
<tt class="descname">mNodeID</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNodeID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNodeMObject">
<tt class="descname">mNodeMObject</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNodeMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>exposed wrapper to return the MObject directly, this passes via the MObjectHandle
to ensure that the MObject cached is still valid</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.lockState">
<tt class="descname">lockState</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.lockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Lockstate is just that, the lockNode state of the Maya node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.setUUID">
<tt class="descname">setUUID</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.setUUID" title="Permalink to this definition">¶</a></dt>
<dd><p>unique UUID used by the caching system</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getUUID">
<tt class="descname">getUUID</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getUUID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.hasAttr">
<tt class="descname">hasAttr</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.hasAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrapper check for attrs on the mNode itself.
Note this is not run in some of the core internal calls in this baseClass</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrIsLocked">
<tt class="descname">attrIsLocked</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrIsLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>check the attribute on the mNode to see if it&#8217;s locked</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrSetLocked">
<tt class="descname">attrSetLocked</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrSetLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>set the lockState of a given attr on the mNode</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.renameAttr">
<tt class="descname">renameAttr</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.renameAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over cmds.renameAttr</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.delAttr">
<tt class="descname">delAttr</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a given attr</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.addAttr">
<tt class="descname">addAttr</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.addAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapped version of Maya addAttr that manages the basic type flags for you
whilst also setting the attr on the MayaNode/class object itself. 
I now merge in <a href="#id1"><span class="problematic" id="id2">**</span></a>kws to the dict I pass to the add and set commands here so you 
can specify all standard cmds.addAttr, setAttr flags in the same call.
ie min, max, l, k, cb</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> &#8211; attribute name to add (standard &#8216;longName&#8217; flag)</li>
<li><strong>value</strong> &#8211; initial value to set, if a value is given the attribute type is automatically 
determined for you.</li>
<li><strong>attrType</strong> &#8211; specify the exact type of attr to add. By default I try and resolve 
this for you from the type of value passed in.</li>
<li><strong>hidden</strong> &#8211; whether the attr is set available in the channelBox (only applies keyable attrs)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>specific attr management for given types below:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">double3</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s">&#39;double3&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="n">value2</span><span class="p">,</span><span class="n">value3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">float3</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s">&#39;float3&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="n">value2</span><span class="p">,</span><span class="n">value3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s">&#39;enum&#39;</span><span class="p">,</span>   <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">enumName</span><span class="o">=</span><span class="s">&#39;Centre:Left:Right&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doubleArray</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s">&#39;doubleArray&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="s">&#39;jsonDict&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">:</span><span class="mf">3.3</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">]})</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">max values for int is 2,147,483,647 (int32)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.listAttrsOfType">
<tt class="descname">listAttrsOfType</tt><big>(</big><em>Type='message'</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.listAttrsOfType" title="Permalink to this definition">¶</a></dt>
<dd><p>this is a fast method to list all attrs of type on the mNode</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mNode</span><span class="p">)</span> <span class="k">if</span> <span class="n">cmds</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">attr</span><span class="p">),</span><span class="nb">type</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">==</span><span class="s">&#39;message&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Simply using the above cmds calls is DOG SLOW upto this which goes via the Api.
TODO: expand the Type support here</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.shortName">
<tt class="descname">shortName</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.shortName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.select">
<tt class="descname">select</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.select" title="Permalink to this definition">¶</a></dt>
<dd><p>args and kws are now passed through into the Maya select call</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename the mNode itself, again because we get the mNode via the MObject renaming is handled correctly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; new name for the mNode</li>
<li><strong>renameChildLinks</strong> &#8211; set to False by default, this will rename connections back to the mNode 
from children who are connected directly to it, via an attr that matches the current mNode name. 
These connected Attrs will be renamed to reflect the change in node name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.delete">
<tt class="descname">delete</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the mNode and this class instance</p>
<p>Note that if you delete a &#8216;network&#8217; node then by default
Maya will delete connected child nodes unless they&#8217;re wired. 
To prevent this set the self.lockState=True in your classes __init__</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isReferenced">
<tt class="descname">isReferenced</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isReferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>is node.mNode referenced?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.referenceNode">
<tt class="descname">referenceNode</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.referenceNode" title="Permalink to this definition">¶</a></dt>
<dd><p>if referenced return the referenceNode itself</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.referencePath">
<tt class="descname">referencePath</tt><big>(</big><em>wcn=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.referencePath" title="Permalink to this definition">¶</a></dt>
<dd><p>if referenced return the referenced filepath</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.nameSpace">
<tt class="descname">nameSpace</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.nameSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag has been modified to return just the direct namespace
of the node, not all nested namespaces if found. Now returns a string</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.nameSpaceFull">
<tt class="descname">nameSpaceFull</tt><big>(</big><em>asList=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.nameSpaceFull" title="Permalink to this definition">¶</a></dt>
<dd><p>the namespace call has been modified to only return the single 
direct namespace of a node, not the nested. This new func will
return the namespace in it&#8217;s entirity either as a list or a 
catenated string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>asList</strong> &#8211; either return the namespaces in a list or as a catenated string (default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isChildNode">
<tt class="descname">isChildNode</tt><big>(</big><em>node</em>, <em>attr=None</em>, <em>srcAttr=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isChildNode" title="Permalink to this definition">¶</a></dt>
<dd><p>test if a node is already connected to the mNode via a given attr link.
Why the wrap? well this gets over the issue of array index&#8217;s in the connections</p>
<p>cmds.isConnected(&#8216;node.attr[0]&#8217;,&#8217;other.attr[0]&#8217;)
fails if simply asked:
cmds.isConnected(&#8216;node.attr&#8217;,other.attr&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectChildren">
<tt class="descname">connectChildren</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting multiple nodes to the mNode via a message attr link.
This call generates a MULTI message on both sides of the connection and is designed
for more complex parent child relationships</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; Maya nodes to connect to this mNode</li>
<li><strong>attr</strong> &#8211; Name for the message attribute</li>
<li><strong>srcAttr</strong> &#8211; if given this becomes the attr on the child node which connects it
to self.mNode. If NOT given this attr is set to self.mNodeID</li>
<li><strong>cleanCurrent</strong> &#8211; Disconnect and clean any currently connected nodes to this attr.
Note this is operating on the mNode side of the connection, removing
any currently connected nodes to this attr prior to making the new ones</li>
<li><strong>force</strong> &#8211; Maya&#8217;s default connectAttr &#8216;force&#8217; flag, if the srcAttr is already connected
to another node force the connection to the new attr</li>
<li><strong>allowIncest</strong> &#8211; Over-ride the default behaviour when dealing with child nodes that are
standard Maya Nodes not metaNodes. Default in this case is to NOT index manage
the plugs, this flag overloads that, allow multiple parents.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: check the attr type, if attr exists and is a non-multi messgae then don&#8217;t run the indexBlock</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectChild">
<tt class="descname">connectChild</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting a node to the mNode via a message attr link. This call
generates a NONE-MULTI message on both sides of the connection and is designed
for simple parent child relationships.</p>
<p>NOTE: this call by default manages the attr to only ONE CHILD to
avoid this use cleanCurrent=False
:param node: Maya node to connect to this mNode
:param attr: Name for the message attribute
:param srcAttr: If given this becomes the attr on the child node which connects it</p>
<blockquote>
to self.mNode. If NOT given this attr is set to self.mNodeID</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cleanCurrent</strong> &#8211; Disconnect and clean any currently connected nodes to this attr.
Note this is operating on the mNode side of the connection, removing
any currently connected nodes to this attr prior to making the new ones</li>
<li><strong>force</strong> &#8211; Maya&#8217;s default connectAttr &#8216;force&#8217; flag, if the srcAttr is already connected
to another node force the connection to the new attr</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: do we move the cleanCurrent to the end so that if the connect fails you&#8217;re not left
with a half run setup?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectParent">
<tt class="descname">connectParent</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting message links to the mNode as parents
:param nodes: Maya nodes to connect to this mNode
:param attr: Name for the message attribute on eth PARENT!
:param srcAttr: If given this becomes the attr on the node which connects it</p>
<blockquote>
to the parent. If NOT given this attr is set to parents shortName</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cleanCurrent</strong> &#8211; Exposed from teh connectChild code which is basically what this is running in reverse</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: Modify so if a metaClass is passed in use it&#8217;s addAttr cmd so the new
attr is registered in the class given</p>
<p>TODO: Manage connection Index like the connectChildren call does?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.disconnectChild">
<tt class="descname">disconnectChild</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.disconnectChild" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect a given child node from the mNode. Default is to remove
the connection attribute in the process, cleaning up both sides of
the connection. Note that the attrs only get removed if nothing
else is connected to it, ie, it&#8217;s safe to do so.
:param node: the Maya node to disconnect from the mNode
:param deleteSourcePlug: if True delete SOURCE side attribiute after disconnection</p>
<blockquote>
but ONLY if it&#8217;s no longer connected to anything else.</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>deleteDestPlug</strong> &#8211; if True delete the DESTINATION side attribiute after disconnection
but ONLY if it&#8217;s no longer connected to anything else.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c">#testCode:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span>  <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;master&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master2</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;master2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child1</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;child1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child2</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;child2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span><span class="o">=</span><span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">polyCube</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">l</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="p">,</span><span class="n">child2</span><span class="p">,</span><span class="n">cube</span><span class="p">],</span><span class="s">&#39;modules&#39;</span><span class="p">,</span><span class="s">&#39;puppet&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master2</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">child2</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">cube</span><span class="p">],</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;master&#39;</span><span class="p">,</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="p">,</span><span class="n">child2</span><span class="p">],</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;master&#39;</span><span class="p">,</span><span class="n">cleanCurrent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">disconnectChild</span><span class="p">(</span><span class="n">child2</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">disconnectChild</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.addChildMetaNode">
<tt class="descname">addChildMetaNode</tt><big>(</big><em>mClass</em>, <em>attr</em>, <em>srcAttr=None</em>, <em>nodeName=None</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.addChildMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic call to add a MetaNode as a Child of self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mClass</strong> &#8211; mClass to generate, given as a valid key to the 
RED9_META_REGISTERY ie &#8216;MetaRig&#8217; OR a class object, ie r9Meta.MetaRig</li>
<li><strong>attr</strong> &#8211; message attribute to wire the new node too</li>
<li><strong>name</strong> &#8211; optional name to give the new name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getChildMetaNodes">
<tt class="descname">getChildMetaNodes</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getChildMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find any connected Child MetaNodes to this mNode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> &#8211; walk the connected network and return ALL children conntected in the tree</li>
<li><strong>mAttrs</strong> &#8211; only return connected nodes that pass the given attribute filter</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mAttrs is only searching attrs on the mNodes themselves, not all children
and although there is no mTypes flag, you can use mAttrs to get childnodes of type
by going getChildMetaNodes(mAttrs=&#8217;mClass=MetaRig&#8217;)</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id3"><span class="problematic" id="id4">**</span></a>kws are passed directly to the getConnectedMetaNods func, it will
also take ALL of that functions <a href="#id5"><span class="problematic" id="id6">**</span></a>kws functionality in the initial search:
source=True, destination=True, mTypes=[], mInstances=[], mAttrs=None, dataType=&#8217;mClass&#8217;</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Todo :</th><td class="field-body">allow this to walk over nodes, at the moment if the direct child isn&#8217;t of the correct 
type (if using the mTypes flag) then the walk will stop. This should continue over non matching 
nodes down the hierarchy so all children are tested.
!!!!!!!!!!!!!! THIS NEEDS FIXING ASAP !!!!!!!!!!!!!! or at least a flag to &#8216;skip_over_unmatched&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getParentMetaNode">
<tt class="descname">getParentMetaNode</tt><big>(</big><em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getParentMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Find any connected Parent MetaNode to this mNode</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id7"><span class="problematic" id="id8">**</span></a>kws are passed directly to the getConnectedMetaNods func, it will
also take ALL of that functions kws
source=True, destination=True, mTypes=[], mInstances=[], mAttrs=None, dataType=&#8217;mClass&#8217;</p>
</div>
<p>TODO: implement a walk here to go upstream</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getChildren">
<tt class="descname">getChildren</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>This finds all UserDefined attrs of type message and returns all connected nodes
This is now being run in the MetaUI on doubleClick. This is a generic call, implemented
and over-loaded on a case by case basis. At the moment the MetaRig class simple calls
mRig.getRigCtrls() in the call, but it means that we don&#8217;t call .mRig.getRigCtrls()
in generic meta functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> &#8211; walk all subMeta connections and include all their children too</li>
<li><strong>mAttrs</strong> &#8211; only search connected mNodes that pass the given attribute filter (attr is at the metaSystems level)</li>
<li><strong>cAttrs</strong> &#8211; only pass connected children whos connection to the mNode matches the given attr (accepts wildcards)</li>
<li><strong>nAttrs</strong> &#8211; search returned MayaNodes for given set of attrs and only return matched nodes</li>
<li><strong>asMeta</strong> &#8211; return instantiated mNodes regardless of type</li>
<li><strong>asMap</strong> &#8211; return the data as a map such that {mNode.plugAttr:[nodes], mNode.plugAttr:[nodes]}</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mAttrs is only searching attrs on the mNodes themselves, not the children
cAttrs is searching the connection attr names from the mNodes, uses the cmds.listAttr &#8216;st&#8217; flag</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnectionMetaDataMap">
<em class="property">static </em><tt class="descname">getNodeConnectionMetaDataMap</tt><big>(</big><em>node</em>, <em>mTypes=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnectionMetaDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic wrapper to extract metaData connection info for any given node
used currently to build the pose dict up, and compare / match the data on load.
In the base implementation this gives you a dict of mNodeID and attr which the nodes is connected too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> &#8211; node to inspect and get the connection data back from</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mNodes={} which is directly pushed into the PoseFile under the [metaData] key</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is designed to be overloaded so you can craft your own metaData block in the
poseFiles, allows you to craft the data you want to store against a node.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnetionAttr">
<tt class="descname">getNodeConnetionAttr</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnetionAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>really light wrapper, designed to return the attr via which a node
is connected to this metaNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; node to test connection attr for</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This will be depricated soon and replaced by getNodeConnections which is
more flexible as it returns and filters all plugs between self and the given node.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnections">
<tt class="descname">getNodeConnections</tt><big>(</big><em>node</em>, <em>filters=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnections" title="Permalink to this definition">¶</a></dt>
<dd><p>really light wrapper, designed to return all connections
between a given node and the mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; node to test connection attr for</li>
<li><strong>filters</strong> &#8211; filter string to match for the returns</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.deleteEntireMetaRigStructure">
<tt class="descname">deleteEntireMetaRigStructure</tt><big>(</big><em>searchNode=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.deleteEntireMetaRigStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a hard core unplug and cleanup of all attrs added by the
MetaRig, all connections and all nodes. Use CAREFULLY!</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRig">
<em class="property">class </em><tt class="descname">MetaRig</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></tt></a></p>
<p>Sub-class of Meta used as the back-bone of our internal rigging
systems. This is the core of how we hook all our tools to meta
in a seamless manner and bind some core functionality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of the node and in this case, the RigSystem itself</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.ctrl_main">
<tt class="descname">ctrl_main</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.ctrl_main" title="Permalink to this definition">¶</a></dt>
<dd><p>why wrap, because when we subclass, IF we&#8217;ve modified the CRTL_Prefix then we
can&#8217;t rely on the default CTRL_Main[0] wire, so we wrap it with the current 
instances self.CTRL_Prefix</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.characterSet">
<tt class="descname">characterSet</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.characterSet" title="Permalink to this definition">¶</a></dt>
<dd><p>return the first connected characterSet found to children</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addGenericCtrls">
<tt class="descname">addGenericCtrls</tt><big>(</big><em>nodes</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addGenericCtrls" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass in a list of objects to become generic, non specific
controllers for a given setup. These are all connected to the same slot
so don&#8217;t have the search capability that the funct below gives</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addRigCtrl">
<tt class="descname">addRigCtrl</tt><big>(</big><em>node</em>, <em>ctrType</em>, <em>mirrorData=None</em>, <em>boundData=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addRigCtrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single CTRL of managed type as a child of this mRig.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya node to add</li>
<li><strong>ctrType</strong> &#8211; Attr name to assign this too</li>
<li><strong>mirrorData</strong> &#8211; {side:&#8217;Left&#8217;, slot:int, axis:&#8217;translateX,rotateY,rotateZ&#8217;..}</li>
<li><strong>boundData</strong> &#8211; {} any additional attrData, set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last line-block">
<div class="line">mirrorData[slot] must NOT == 0 as it&#8217;ll be handled as not set by the core.</div>
<div class="line">ctrType &gt;&gt; &#8216;Main&#8217; is the equivalent of the RootNode in the FilterNode calls.</div>
</div>
</div>
<p>TODO: allow the mirror block to include an offset so that if you need to inverse AND offset 
by 180 to get left and right working you can still do so.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getRigCtrls">
<tt class="descname">getRigCtrls</tt><big>(</big><em>walk=False</em>, <em>mAttrs=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getRigCtrls" title="Permalink to this definition">¶</a></dt>
<dd><p>Depricated Code - use getChildren call now</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getChildren">
<tt class="descname">getChildren</tt><big>(</big><em>walk=True</em>, <em>mAttrs=None</em>, <em>cAttrs=</em><span class="optional">[</span><span class="optional">]</span>, <em>nAttrs=</em><span class="optional">[</span><span class="optional">]</span>, <em>asMeta=False</em>, <em>asMap=False</em>, <em>incFacial=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Massively important bit of code, this is used by most bits of code
to find the child controllers linked to this metaRig instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">MetaRig getChildren has overloads adding the CTRL_Prefix to the cAttrs so that
the retunr is just the controllers in the rig. It also now has additional logic
to add any FacialCore system chidren by adding it&#8217;s internal CTRL_Prefix to the list</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getSkeletonRoots">
<tt class="descname">getSkeletonRoots</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getSkeletonRoots" title="Permalink to this definition">¶</a></dt>
<dd><p>get the Skeleton Root, used in the poseSaver. By default this looks
for a message link via the attr &#8220;exportSkeletonRoot&#8221; to the skeletons root jnt
always returns a list!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getFacialSystem">
<tt class="descname">getFacialSystem</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getFacialSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>if we have a FacialCore node return it. This allows you to modify how 
you wire up your facial system to metaData but gives us a consistent hook</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addWristCtrl">
<tt class="descname">addWristCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addWristCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addElbowCtrl">
<tt class="descname">addElbowCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addElbowCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addClavCtrl">
<tt class="descname">addClavCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addClavCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addFootCtrl">
<tt class="descname">addFootCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addFootCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addKneeCtrl">
<tt class="descname">addKneeCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addKneeCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addPropCtrl">
<tt class="descname">addPropCtrl</tt><big>(</big><em>node</em>, <em>side</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addPropCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addMainCtrl">
<tt class="descname">addMainCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addMainCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addRootCtrl">
<tt class="descname">addRootCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addRootCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addHipCtrl">
<tt class="descname">addHipCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addHipCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addChestCtrl">
<tt class="descname">addChestCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addChestCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addHeadCtrl">
<tt class="descname">addHeadCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addHeadCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addNeckCtrl">
<tt class="descname">addNeckCtrl</tt><big>(</big><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addNeckCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addSupportMetaNode">
<tt class="descname">addSupportMetaNode</tt><big>(</big><em>attr</em>, <em>nodeName=None</em>, <em>mClass='MetaRigSupport'</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addSupportMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Not sure the best way to do this, but was thinking that the main mRig
node should be able to have sub MetaClass nodes to cleanly define
what nodes are AnimCtrls, and what nodes you want to tag as Support
subsystems, ie, ikSolvers and construction nodes within the rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> &#8211; Attribute used in the message link. Note this is what you use
to transerve the Dag tree so use something sensible!</li>
<li><strong>nodeName</strong> &#8211; Name of the MetaClass network node created</li>
<li><strong>mClass</strong> &#8211; the class to be used for the support node - &#8216;MetaRigSupport&#8217; by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addSupportNode">
<tt class="descname">addSupportNode</tt><big>(</big><em>node</em>, <em>attr</em>, <em>boundData=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type
Really in the MetaRig design these should be wired to a MetaRigSupport node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya node to add</li>
<li><strong>attr</strong> &#8211; Attr name to assign this too</li>
<li><strong>boundData</strong> &#8211; {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addMetaSubSystem">
<tt class="descname">addMetaSubSystem</tt><big>(</big><em>systemType</em>, <em>side</em>, <em>attr=None</em>, <em>nodeName=None</em>, <em>mClass='MetaRigSubSystem'</em>, <em>buildflags={}</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addMetaSubSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic design of a MetaRig is that you have sub-systems hanging off an mRig
node, managing all controllers and data for a particular system, such as an
Arm system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>systemType</strong> &#8211; Attribute used in the message link. Note this is what you use
to transerve the Dag tree so use something sensible!</li>
<li><strong>mirrorSide</strong> &#8211; Side to designate the system. This is an enum: Centre,Left,Right</li>
<li><strong>nodeName</strong> &#8211; Name of the MetaClass network node created</li>
<li><strong>mClass</strong> &#8211; the class to be used for the support node - &#8216;MetaRigSubSystem&#8217; by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.set_ctrlColour">
<tt class="descname">set_ctrlColour</tt><big>(</big><em>colourIndex=4</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.set_ctrlColour" title="Permalink to this definition">¶</a></dt>
<dd><p>set the override colour of a given nodes shapes</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirrorData">
<tt class="descname">getMirrorData</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirrorData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the MirrorObject to this instance of MetaRig.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">you must run this binding function before using any of
the inbuilt mirror functions</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadMirrorDataMap">
<tt class="descname">loadMirrorDataMap</tt><big>(</big><em>mirrorMap</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadMirrorDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>load a mirror setup onto this rig from a stored mirrorMap file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mirrorMap</strong> &#8211; mirror file to load</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveMirrorDataMap">
<tt class="descname">saveMirrorDataMap</tt><big>(</big><em>filepath</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveMirrorDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>save the current mirror setup for this rig to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> &#8211; filepath to store the mirrorMap too</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_opposites">
<tt class="descname">getMirror_opposites</tt><big>(</big><em>nodes</em>, <em>forceRefresh=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_opposites" title="Permalink to this definition">¶</a></dt>
<dd><p>from the given nodes return a map of the opposite pairs of controllers
so if you pass in a right controller of mirrorIndex 4 you get back the
left[4] mirror node and visa versa. Centre controllers pass straight through</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to get the opposites from</li>
<li><strong>forceRefresh</strong> &#8211; forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_ctrlSets">
<tt class="descname">getMirror_ctrlSets</tt><big>(</big><em>set='Centre'</em>, <em>forceRefresh=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_ctrlSets" title="Permalink to this definition">¶</a></dt>
<dd><p>from  the metaNode grab all controllers and return sets of nodes
based on their mirror side data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>set</strong> &#8211; which set/side to get, valid = &#8216;Left&#8217; ,&#8217;Right&#8217;, &#8216;Center&#8217;</li>
<li><strong>forceRefresh</strong> &#8211; forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_lastIndexes">
<tt class="descname">getMirror_lastIndexes</tt><big>(</big><em>side</em>, <em>forceRefresh=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_lastIndexes" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last mirror index for a given side</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>side</strong> &#8211; side to check, valid = &#8216;Left&#8217; ,&#8217;Right&#8217;, &#8216;Center&#8217;</li>
<li><strong>forceRefresh</strong> &#8211; forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_nextSlot">
<tt class="descname">getMirror_nextSlot</tt><big>(</big><em>side</em>, <em>forceRefresh=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_nextSlot" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next available slot in the mirrorIndex list for a given side</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>side</strong> &#8211; side to check, valid = &#8216;Left&#8217; ,&#8217;Right&#8217;, &#8216;Center&#8217;</li>
<li><strong>forceRefresh</strong> &#8211; forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.mirror">
<tt class="descname">mirror</tt><big>(</big><em>nodes=None</em>, <em>mode='Anim'</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>direct mapper call to the Mirror functions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to mirror, if None then we process the entire rig</li>
<li><strong>mode</strong> &#8211; either &#8216;Anim&#8217; or &#8216;Pose&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCacheStore">
<tt class="descname">poseCacheStore</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCacheStore" title="Permalink to this definition">¶</a></dt>
<dd><p>intended as a cached pose for this mRig, if an attr is given then
the cached pose is stored internally on the node so it can be loaded
back from the mNode internally. If not given then the pose is cached
on this object instance only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> &#8211; optional - attr to store the cached pose to</li>
<li><strong>filepath</strong> &#8211; optional - path to store the pose too</li>
<li><strong>incRoots</strong> &#8211; passed directly to the filterSettings object in the pose, do we process self.ctrl_main?</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCacheLoad">
<tt class="descname">poseCacheLoad</tt><big>(</big><em>nodes=None</em>, <em>attr=None</em>, <em>filepath=None</em>, <em>incRoots=True</em>, <em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCacheLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>load a cached pose back to this mRig. If attr is given then its assumed
that that attr is a cached poseDict on the mNode. If not given then it
will load the cached pose from this objects instance, if there is one stored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; if given load only the cached pose to the given nodes</li>
<li><strong>attr</strong> &#8211; optional - attr in which a pose has been stored internally on the mRig</li>
<li><strong>filepath</strong> &#8211; optional - posefile to load back</li>
<li><strong>incRoots</strong> &#8211; passed directly to the filterSettings object in the pose, do we process self.ctrl_main?</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Todo :</th><td class="field-body"><p class="first last">add relative flags so that they can pass through this call</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCompare">
<tt class="descname">poseCompare</tt><big>(</big><em>poseFile</em>, <em>supressWarning=False</em>, <em>compareDict='skeletonDict'</em>, <em>filterMap=</em><span class="optional">[</span><span class="optional">]</span>, <em>ignoreBlocks=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCompare" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrated poseCompare, this checks the mRigs current pose against
a given poseFile. This checks against the &#8216;skeletonDict&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>poseFile</strong> &#8211; given .pose file with valid skeletonDict block</li>
<li><strong>supressWarning</strong> &#8211; if False raise the confirmDialogue</li>
<li><strong>compareDict</strong> &#8211; what block in the poseFile to compare the data against</li>
<li><strong>filterMap</strong> &#8211; if given this is used as a high level filter, only matching nodes get compared
others get skipped. Good for passing in a master core skeleton to test whilst ignoring extra nodes</li>
<li><strong>ignoreBlocks</strong> &#8211; used to stop certain blocks in the compare from causing a fail eg : [&#8216;missingKeys&#8217;]</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">returns a &#8216;PoseCompare&#8217; class object with all the compare data in it</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.nodeVisibility">
<tt class="descname">nodeVisibility</tt><big>(</big><em>state</em>, <em>skip=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.nodeVisibility" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrapper to hide all ctrls in the rig via their shapeNodes.lodVisibility 
so it doesn&#8217;t interfer with any display layers etc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; bool to pass to the lodVisibility attr</li>
<li><strong>skip</strong> &#8211; [] child attrs on the mNode to skip during the process allowing certain controllers not to be effected</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.hideNodes">
<tt class="descname">hideNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.hideNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over the nodeVisibility to set False for all Controllers
with the exceptiojn of the Main_Ctrl</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.unHideNodes">
<tt class="descname">unHideNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.unHideNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over the nodeVisibility to set True for all Controllers
with the exceptiojn of the Main_Ctrl</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveAttrMap">
<tt class="descname">saveAttrMap</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveAttrMap" title="Permalink to this definition">¶</a></dt>
<dd><p>store AttrMap to the metaRig, saving the chBox state of ALL attrs for ALL nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadAttrMap">
<tt class="descname">loadAttrMap</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadAttrMap" title="Permalink to this definition">¶</a></dt>
<dd><p>load AttrMap from the metaRig, returning the chBox state of ALL attrs for ALL nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveZeroPose">
<tt class="descname">saveZeroPose</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveZeroPose" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize the r9Pose file to the node itself</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadZeroPose">
<tt class="descname">loadZeroPose</tt><big>(</big><em>nodes=None</em>, <em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadZeroPose" title="Permalink to this definition">¶</a></dt>
<dd><p>load the zeroPose form the internal dict</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; optional, load at subSystem level for given nodes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getAnimationRange">
<tt class="descname">getAnimationRange</tt><big>(</big><em>nodes=None</em>, <em>setTimeline=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getAnimationRange" title="Permalink to this definition">¶</a></dt>
<dd><p>return the extend of the animation range for this rig and / or the given controllers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; if given only return the extent of the animation data from the given nodes</li>
<li><strong>setTimeLine</strong> &#8211; if True set the playback timeranges also, default=False</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.hasKeys">
<tt class="descname">hasKeys</tt><big>(</big><em>nodes=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.hasKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>return True if any of the rig&#8217;s controllers have existing
animation curve/key data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to check, if None process the entire rig</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.cutKeys">
<tt class="descname">cutKeys</tt><big>(</big><em>nodes=</em><span class="optional">[</span><span class="optional">]</span>, <em>reset=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.cutKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>cut all animation keys from the rig and reset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; if passed in only cutKeys on given nodes</li>
<li><strong>reset</strong> &#8211; if true reset the rig after key removal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveAnimation">
<tt class="descname">saveAnimation</tt><big>(</big><em>filepath</em>, <em>incRoots=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveAnimation" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO_PACK : Binding of the animMap format for storing animation data out to file</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadAnimation">
<tt class="descname">loadAnimation</tt><big>(</big><em>filepath</em>, <em>offset=0</em>, <em>incRoots=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadAnimation" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO_PACK : Binding of the animMap format for loading animation data from
an r9Anim file</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.Timecode">
<tt class="descname">Timecode</tt><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.Timecode" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO_PACK : bind the Pro Timecode class to the node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_get">
<tt class="descname">timecode_get</tt><big>(</big><em>atFrame=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_get" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO PACK: get the timecode object back from the rig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_addAttrs">
<tt class="descname">timecode_addAttrs</tt><big>(</big><em>tc=''</em>, <em>propagate=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_addAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO PACK: simple return to check if the system has the Pro Timecode
systems bound to it</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_hasTimeCode">
<tt class="descname">timecode_hasTimeCode</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_hasTimeCode" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO PACK: simple return to check if the system has the Pro Timecode
systems bound to it</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_remove">
<tt class="descname">timecode_remove</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>PRO PACK: simple return to check if the system has the Pro Timecode
systems bound to it</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRigSubSystem">
<em class="property">class </em><tt class="descname">MetaRigSubSystem</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSubSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></tt></a></p>
<p>SubClass of the MRig, designed to organize Rig sub-systems (ie L_ArmSystem, L_LegSystem..)
within a complex rig structure. This or MetaRig should have the Controllers wired to it</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRigSupport">
<em class="property">class </em><tt class="descname">MetaRigSupport</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></tt></a></p>
<p>SubClass of MetaClass, designed to organize support nodes, solvers and other internal
nodes within a complex rig structure which you may need to ID at a later date.
Controllers should NOT be wired to this node</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRigSupport.addSupportNode">
<tt class="descname">addSupportNode</tt><big>(</big><em>node</em>, <em>attr</em>, <em>boundData=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSupport.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya node to add</li>
<li><strong>attr</strong> &#8211; Attr name to assign this too</li>
<li><strong>boundData</strong> &#8211; {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaFacialRig">
<em class="property">class </em><tt class="descname">MetaFacialRig</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></tt></a></p>
<p>SubClass of the MetaRig, designed to be manage Facial systems in the MetaData
Dag tree for organizing Facial Controllers and support nodes</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaFacialRigSupport">
<em class="property">class </em><tt class="descname">MetaFacialRigSupport</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRigSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></tt></a></p>
<p>SubClass of the MetaClass, designed to organize support nodes, solvers and other internal
nodes within a complex rig structure which you may need to ID at a later date.
Controllers should NOT be wired to this node</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaFacialRigSupport.addSupportNode">
<tt class="descname">addSupportNode</tt><big>(</big><em>node</em>, <em>attr</em>, <em>boundData=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRigSupport.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; Maya node to add</li>
<li><strong>attr</strong> &#8211; Attr name to assign this too</li>
<li><strong>boundData</strong> &#8211; {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode">
<em class="property">class </em><tt class="descname">MetaHIKCharacterNode</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></tt></a></p>
<p>Casting HIK directly to a metaClass so it&#8217;s treated as meta by default.
Why the hell not, it&#8217;s a complex character node that is default in Maya
and useful for management in the systems</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKControlSetNode">
<tt class="descname">getHIKControlSetNode</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKControlSetNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.delete">
<tt class="descname">delete</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete hik node and dependency nodes
:return:</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.openui">
<em class="property">static </em><tt class="descname">openui</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.openui" title="Permalink to this definition">¶</a></dt>
<dd><p>Open hik UI</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.lock">
<tt class="descname">lock</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock hik characterisation
:return: True if lock False if not lock</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.unLock">
<tt class="descname">unLock</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.unLock" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock hik characterisation</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.getCurrentCharacter">
<em class="property">static </em><tt class="descname">getCurrentCharacter</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.getCurrentCharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>get current hik character
:return: current hik charactre name</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.setascurrentcharacter">
<tt class="descname">setascurrentcharacter</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.setascurrentcharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>set current mNode as hikcurrentcharacter</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.checkcharacterization">
<tt class="descname">checkcharacterization</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.checkcharacterization" title="Permalink to this definition">¶</a></dt>
<dd><p>check that hikNode characterisation is valid
:return: True if valid False if invalid</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode">
<em class="property">class </em><tt class="descname">MetaHIKControlSetNode</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></tt></a></p>
<p>Casting HIK directly to a metaClass so it&#8217;s treated as meta by default.
Why the hell not, it&#8217;s a complex character node that is default in Maya
and useful for management in the systems</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode.getHIKCharacterNode">
<tt class="descname">getHIKCharacterNode</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode.getHIKCharacterNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode.getChildren">
<tt class="descname">getChildren</tt><big>(</big><em>walk=False</em>, <em>mAttrs=None</em>, <em>cAttrs=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Carefully over-loaded for HIK system</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDaddCBAttrs">
<tt class="descname">monitorHUDaddCBAttrs</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDaddCBAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD : 
Adds selected attrs from the CB to a MetaHUD node for monitoring,
if HUD node already exists this will simply add more attrs to it</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDManagement">
<tt class="descname">monitorHUDManagement</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDManagement" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD : kill any current MetaHUD headsUpDisplay blocks</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDremoveCBAttrs">
<tt class="descname">monitorHUDremoveCBAttrs</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDremoveCBAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD : remove attrs from the MetaHUD</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.hardKillMetaHUD">
<tt class="descname">hardKillMetaHUD</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.hardKillMetaHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>If the MetaNodes are left behind in a scene and you can&#8217;t remove them
then this is a hard coded kill to remove the hud element. This situation 
happens if you&#8217;d deleted the MetaHUDNode but left the draw on, meaning
we now have invalid HUD data drawn.</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHUDNode">
<em class="property">class </em><tt class="descname">MetaHUDNode</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></tt></a></p>
<p>SubClass of the MetaClass, designed as a simple interface
for HUD management in Maya. Any monitored attrs added to the MetaNode
will show in the HUD when drawn.</p>
<p>The idea is that we have a single MetaNode with attrs that are monitored
and managed for HUD display. To get an attr onto the HUD all you need to do
is add it using addMonitoredAttr(), then drawHUD(). All I do is connect the HUD
attr to the attr that you want to monitor, it just sits as a new wired node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Todo :</th><td class="field-body">Look if we can link the Section and Block attrs to the refresh func 
via an attrChange callback</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.addMonitoredAttr">
<tt class="descname">addMonitoredAttr</tt><big>(</big><em>attr</em>, <em>value=None</em>, <em>attrType=None</em>, <em>refresh=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.addMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper that not only adds an attr to the metaNode, but also adds it
to the internal list of attributes that are monitored and added
to the HUD when drawn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> &#8211; attr to be added to the node for monitoring in the HUD</li>
<li><strong>value</strong> &#8211; Initial value of the attr so the node can figure out what type of attr it is</li>
<li><strong>attrType</strong> &#8211; specifiy the attr type directly</li>
<li><strong>refresh</strong> &#8211; whether to refresh the HUD after adding a new attr</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this ties in with the default addAttr call hence the args are very similar in function</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.removeMonitoredAttr">
<tt class="descname">removeMonitoredAttr</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.removeMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an attr from the MetaNode and refresh the HUD to reflect the removal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> &#8211; attr to be removed from monitoring</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getHudDisplays">
<tt class="descname">getHudDisplays</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getHudDisplays" title="Permalink to this definition">¶</a></dt>
<dd><p>each line in the HUD is actually a separate HUD in itself so we need
to carefully manage this list</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.drawHUD">
<tt class="descname">drawHUD</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.drawHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>Push the monitored attrs up to the Maya HUD in the viewport</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getConnectedAttr">
<tt class="descname">getConnectedAttr</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getConnectedAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getConnectedNode">
<tt class="descname">getConnectedNode</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getConnectedNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.setSlidertoAttr">
<tt class="descname">setSlidertoAttr</tt><big>(</big><em>slider</em>, <em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.setSlidertoAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.resetSlider">
<tt class="descname">resetSlider</tt><big>(</big><em>slider</em>, <em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.resetSlider" title="Permalink to this definition">¶</a></dt>
<dd><p>If the HUD is made up of sliders this resets them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>slider</strong> &#8211; slider to reset in the HUD</li>
<li><strong>attr</strong> &#8211; attr to reset on the mNode</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.showHud">
<tt class="descname">showHud</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.showHud" title="Permalink to this definition">¶</a></dt>
<dd><p>manage the visibility state of the HUD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> &#8211; show or hide the HUD</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.killHud">
<tt class="descname">killHud</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.killHud" title="Permalink to this definition">¶</a></dt>
<dd><p>kill the HUD display altogether</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.refreshHud">
<tt class="descname">refreshHud</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.refreshHud" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the HUD by killing it and re-drawing it from scratch</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.delete">
<tt class="descname">delete</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>full cleanup, remove the metaNode and all HUDs in the process</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaTimeCodeHUD">
<em class="property">class </em><tt class="descname">MetaTimeCodeHUD</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaTimeCodeHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaHUDNode" title="Red9.core.Red9_Meta.MetaHUDNode"><tt class="xref py py-class docutils literal"><span class="pre">Red9.core.Red9_Meta.MetaHUDNode</span></tt></a></p>
<p>Generate&#8217;s a HUD node connected to the main timecode attrs,
allows us to show the actual internal timecode attrs as their 
original SMPTE time&#8217;s</p>
<p>Crucial things to be aware of:</p>
<p>We construct timecode from 3 attrs on the given node: 
timecode_ref        : the original timecode converted to milliseconds 
timecode_count      : a linear curve that increments every frame based on the samplerate 
timecode_samplerate : samplerate that the linear counter was generated against</p>
<p>SMPTE timecode is then reconstructed like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r9Audio</span><span class="o">.</span><span class="n">milliseconds_to_Timecode</span><span class="p">(</span><span class="n">ref</span> <span class="o">+</span> <span class="p">((</span><span class="n">count</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span> 
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">=</span><span class="n">cFacialMeta</span><span class="o">.</span><span class="n">MetaTimeCodeHUD</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">.</span><span class="n">addMonitoredTimecodeNode</span><span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">sl</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">.</span><span class="n">drawHUD</span><span class="p">()</span> 
</pre></div>
</div>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaTimeCodeHUD.addMonitoredTimecodeNode">
<tt class="descname">addMonitoredTimecodeNode</tt><big>(</big><em>nodes</em>, <em>valid=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaTimeCodeHUD.addMonitoredTimecodeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>add a node with the TimeCode attrs on it to monitor</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaTimeCodeHUD.removeMonitoredAttr">
<tt class="descname">removeMonitoredAttr</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaTimeCodeHUD.removeMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaTimeCodeHUD.connectTimecodeSystems">
<tt class="descname">connectTimecodeSystems</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.MetaTimeCodeHUD.connectTimecodeSystems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.metaData_sceneCleanups">
<tt class="descname">metaData_sceneCleanups</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_Meta.metaData_sceneCleanups" title="Permalink to this definition">¶</a></dt>
<dd><p>Registered on SceneOpen and SceneNew callbacks so that the MetaData Cache is cleared and 
any registered HUD is killed off</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Red9_Meta</a><ul>
<li><a class="reference internal" href="#vimeo-demos">Vimeo Demos:</a><ul>
<li><a class="reference internal" href="#basic-metaclass-use">Basic MetaClass Use:</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Red9_General.html"
                        title="previous chapter">Red9_General</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Red9_PoseSaver.html"
                        title="next chapter">Red9_PoseSaver</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/red9templates/Red9_Meta.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Red9_PoseSaver.html" title="Red9_PoseSaver"
             >next</a> |</li>
        <li class="right" >
          <a href="Red9_General.html" title="Red9_General"
             >previous</a> |</li>
        <li><a href="../index.html">Red9 v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Mark Jackson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
    </div>
  </body>
</html>