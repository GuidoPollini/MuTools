
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Red9_CoreUtils &mdash; Red9 v2.0 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Red9 v2.0 documentation" href="../index.html" />
    <link rel="next" title="Red9_General" href="Red9_General.html" />
    <link rel="prev" title="Red9_Audio" href="Red9_Audio.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Red9_General.html" title="Red9_General"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Red9_Audio.html" title="Red9_Audio"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Red9 v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="red9-coreutils">
<h1>Red9_CoreUtils<a class="headerlink" href="#red9-coreutils" title="Permalink to this headline">¶</a></h1>
<p>Red9_CoreUtils is the backbone of much of the systems, used to filter, find and process nodes
on mass withing Maya as well as containing a lot of core functions for dealing with data.</p>
<p>The FilterNode and FilterSettings classes are used throughout the pack, in fact any
time the tools process a hierarchy it&#8217;s these classes that deal with it.</p>
<span class="target" id="module-Red9.core.Red9_CoreUtils"></span><p class="rubric">Core Functions</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.nodeNameStrip" title="Red9.core.Red9_CoreUtils.nodeNameStrip"><tt class="xref py py-obj docutils literal"><span class="pre">nodeNameStrip</span></tt></a>(node)</td>
<td>Simple method to strip any <a href="#id1"><span class="problematic" id="id2">|</span></a>Path and :Namespaces: from</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.prioritizeNodeList" title="Red9.core.Red9_CoreUtils.prioritizeNodeList"><tt class="xref py py-obj docutils literal"><span class="pre">prioritizeNodeList</span></tt></a>(*args,&nbsp;**kws)</td>
<td>Simple function to force the order of a given nList such that nodes</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.sortNumerically" title="Red9.core.Red9_CoreUtils.sortNumerically"><tt class="xref py py-obj docutils literal"><span class="pre">sortNumerically</span></tt></a>(data)</td>
<td>Sort the given data in the way that humans expect.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.stringReplace" title="Red9.core.Red9_CoreUtils.stringReplace"><tt class="xref py py-obj docutils literal"><span class="pre">stringReplace</span></tt></a>(text,&nbsp;replace_dict)</td>
<td>Replace words in a text that match a key in replace_dict with the associated value, return the modified text.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.matchNodeLists" title="Red9.core.Red9_CoreUtils.matchNodeLists"><tt class="xref py py-obj docutils literal"><span class="pre">matchNodeLists</span></tt></a>(nodeListA,&nbsp;nodeListB[,&nbsp;...])</td>
<td>Matches 2 given NODE LISTS by node name via various methods.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.getBlendTargetsFromMesh" title="Red9.core.Red9_CoreUtils.getBlendTargetsFromMesh"><tt class="xref py py-obj docutils literal"><span class="pre">getBlendTargetsFromMesh</span></tt></a>(node[,&nbsp;asList,&nbsp;...])</td>
<td>quick func to return the blendshape targets found from a give mesh&#8217;s connected blendshape&#8217;s</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.timeOffset_addPadding" title="Red9.core.Red9_CoreUtils.timeOffset_addPadding"><tt class="xref py py-obj docutils literal"><span class="pre">timeOffset_addPadding</span></tt></a>([pad,&nbsp;padfrom,&nbsp;scene])</td>
<td>simple wrap of the timeoffset class which will add padding into the</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.timeOffset_collapse" title="Red9.core.Red9_CoreUtils.timeOffset_collapse"><tt class="xref py py-obj docutils literal"><span class="pre">timeOffset_collapse</span></tt></a>([scene,&nbsp;timerange])</td>
<td>Light wrap over the TimeOffset call to manage collapsing time</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.decodeString" title="Red9.core.Red9_CoreUtils.decodeString"><tt class="xref py py-obj docutils literal"><span class="pre">decodeString</span></tt></a>(val)</td>
<td>From configObj the return is a string, we want to encode</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.floatIsEqual" title="Red9.core.Red9_CoreUtils.floatIsEqual"><tt class="xref py py-obj docutils literal"><span class="pre">floatIsEqual</span></tt></a>(a,&nbsp;b[,&nbsp;tolerance,&nbsp;allowGimbal])</td>
<td>compare 2 floats with tolerance.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.valueToMappedRange" title="Red9.core.Red9_CoreUtils.valueToMappedRange"><tt class="xref py py-obj docutils literal"><span class="pre">valueToMappedRange</span></tt></a>(value,&nbsp;currentMin,&nbsp;...)</td>
<td>Acts like the setRange node but code side</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.distanceBetween" title="Red9.core.Red9_CoreUtils.distanceBetween"><tt class="xref py py-obj docutils literal"><span class="pre">distanceBetween</span></tt></a>(nodeA,&nbsp;nodeB)</td>
<td>simple calculation to return the distance between 2 objects</td>
</tr>
</tbody>
</table>
<p class="rubric">Core Classes</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings" title="Red9.core.Red9_CoreUtils.FilterNode_Settings"><tt class="xref py py-obj docutils literal"><span class="pre">FilterNode_Settings</span></tt></a>()</td>
<td>Simple concept, this settings object is passed into the filterNode Calls</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.FilterNode" title="Red9.core.Red9_CoreUtils.FilterNode"><tt class="xref py py-obj docutils literal"><span class="pre">FilterNode</span></tt></a>([roots,&nbsp;filterSettings])</td>
<td>FilterNode is a class for managing, searching and filtering nodes with the scene.</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.MatchedNodeInputs" title="Red9.core.Red9_CoreUtils.MatchedNodeInputs"><tt class="xref py py-obj docutils literal"><span class="pre">MatchedNodeInputs</span></tt></a>([nodes,&nbsp;filterSettings,&nbsp;...])</td>
<td>Class to process and match input nodes for most of the Hierarchy/Anim</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.LockChannels" title="Red9.core.Red9_CoreUtils.LockChannels"><tt class="xref py py-obj docutils literal"><span class="pre">LockChannels</span></tt></a>()</td>
<td>Simple UI to manage the lock and key status of nodes</td>
</tr>
<tr><td><a class="reference internal" href="#Red9.core.Red9_CoreUtils.TimeOffset" title="Red9.core.Red9_CoreUtils.TimeOffset"><tt class="xref py py-obj docutils literal"><span class="pre">TimeOffset</span></tt></a></td>
<td>A class for dealing with time manipulation inside Maya.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.nodeNameStrip">
<tt class="descname">nodeNameStrip</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.nodeNameStrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple method to strip any <a href="#id3"><span class="problematic" id="id4">|</span></a>Path and :Namespaces: from
a given object DagPath ie Ns:Rig|Ns:Leg|Ns:Foot == Foot</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.prioritizeNodeList">
<tt class="descname">prioritizeNodeList</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.prioritizeNodeList" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple function to force the order of a given nList such that nodes
in the given priority list are moved to the front of the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputlist</strong> &#8211; main input list</li>
<li><strong>priorityList</strong> &#8211; list which is used to prioritize/order the main nList</li>
<li><strong>regex</strong> &#8211; Switches from regex search to simple exact node name</li>
<li><strong>prioritysOnly</strong> &#8211; return just the priorityList matches or the entire list sorted</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>#Known issue, if Regex=True and you have 2 similar str&#8217;s in the priority list then there&#8217;s 
a chance that matching may be erractic...</p>
<p>priorityList=[&#8216;upperLip&#8217;,&#8217;l_upperLip&#8217;]
nodes=[&#8216;<a href="#id5"><span class="problematic" id="id6">|</span></a>my|dag|path|jaw&#8217;,|my|dag|path|l_upperLip&#8217;,&#8217;<a href="#id7"><span class="problematic" id="id8">|</span></a>my|dag|path|upperLip&#8217;,&#8217;<a href="#id9"><span class="problematic" id="id10">|</span></a>my|dag|path|lowerLip&#8217;]
returns: [&#8216;<a href="#id11"><span class="problematic" id="id12">|</span></a>my|dag|path|l_upperLip&#8217;,&#8217;<a href="#id13"><span class="problematic" id="id14">|</span></a>my|dag|path|upperLip&#8217;,|my|dag|path|jaw,&#8217;<a href="#id15"><span class="problematic" id="id16">|</span></a>my|dag|path|lowerLip]</p>
<p>as in regex &#8216;l_upperLip&#8217;==&#8217;upperLip&#8217; as well as &#8216;upperLip&#8217;==&#8217;upperLip&#8217;</p>
<p>really in regex you&#8217;d need to be more specific:  priorityList=[&#8216;^upperLip&#8217;,&#8217;l_upperLip&#8217;]</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.sortNumerically">
<tt class="descname">sortNumerically</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.sortNumerically" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the given data in the way that humans expect.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Joint_1&#39;</span><span class="p">,</span><span class="s">&#39;Joint_2&#39;</span><span class="p">,</span><span class="s">&#39;Joint_9&#39;</span><span class="p">,</span><span class="s">&#39;Joint_10&#39;</span><span class="p">,</span><span class="s">&#39;Joint_11&#39;</span><span class="p">,</span><span class="s">&#39;Joint_12&#39;</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#standard gives us:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="s">&#39;Joint_1&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_10&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_11&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_12&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_2&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_9&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#sortNumerically gives us:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sortNumerically</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="s">&#39;Joint_1&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_2&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_9&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_10&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_11&#39;</span><span class="p">,</span> <span class="s">&#39;Joint_12&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.stringReplace">
<tt class="descname">stringReplace</tt><big>(</big><em>text</em>, <em>replace_dict</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.stringReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace words in a text that match a key in replace_dict
with the associated value, return the modified text.
Only whole words are replaced.
Note that replacement is case sensitive, but attached
quotes and punctuation marks are neutral.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.decodeString">
<tt class="descname">decodeString</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.decodeString" title="Permalink to this definition">¶</a></dt>
<dd><p>From configObj the return is a string, we want to encode
it back to it&#8217;s original state so we pass it through this</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.validateString">
<tt class="descname">validateString</tt><big>(</big><em>strText</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.validateString" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to validate that a string has no illegal characters</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.filterListByString">
<tt class="descname">filterListByString</tt><big>(</big><em>input_list</em>, <em>filter_string</em>, <em>matchcase=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.filterListByString" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic way to filter a list by a given string input. This is so that all
the filtering used in the UI&#8217;s is consistent. Used by the poseSaver, facialUI,
MetaUI and many others.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>iniput_list</strong> &#8211; list of strings to be filtered</li>
<li><strong>filter_string</strong> &#8211; string to use in the filter, supports comma separated search strings
eg : &#8216;brows,smile,funnel&#8217;</li>
<li><strong>matchcase</strong> &#8211; whether to match or ignore case sensitivity</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings">
<em class="property">class </em><tt class="descname">FilterNode_Settings</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple concept, this settings object is passed into the filterNode Calls
and is used to setup how hierarchies are processed and filtered. This is
class is used through out Red in conjunction with the filterNode class.</p>
<dl class="docutils">
<dt>Default settings bound:</dt>
<dd><ul class="first last simple">
<li>nodeTypes: []  - search for given Maya nodeTypes&#8217;</li>
<li>searchAttrs: [] - search for given attributes on nodes</li>
<li>searchPattern: [] - search for nodeName patterns</li>
<li>hierarchy: False - full hierarchy process</li>
<li>metaRig: False - ??Do we do this here?? {&#8216;MetaClass&#8217;,&#8217;functCall&#8217;}</li>
<li>filterPriority: [] - A way of re-ordering the hierarchy lists</li>
<li>incRoots: True - process rootNodes in the filters</li>
<li>transformClamp: True - clamp any nodes found to their transforms</li>
<li>infoBlock: &#8216;&#8217;</li>
<li>rigData: {}</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings.filterIsActive">
<tt class="descname">filterIsActive</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings.filterIsActive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings.printSettings">
<tt class="descname">printSettings</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings.printSettings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings.resetFilters">
<tt class="descname">resetFilters</tt><big>(</big><em>rigData=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings.resetFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the MAIN filter args only</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rigData</strong> &#8211; this is a cached attr and not fully handled</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>by the UI hence the option NOT to reset, used by the UI presetFill calls</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings.write">
<tt class="descname">write</tt><big>(</big><em>filepath</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings.write" title="Permalink to this definition">¶</a></dt>
<dd><p>write the filterSettings attribute out to a ConfigFile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> &#8211; file path to write the configFile out to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_Settings.read">
<tt class="descname">read</tt><big>(</big><em>filepath</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_Settings.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a given ConfigFile and fill this object instance with the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> &#8211; file path to write the configFile out to</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>::note ..</dt>
<dd>If filepath doesn&#8217;t exists or you pass in just the short name of the config you 
want to load then we try and find a matching config in the default presets dir in Red9</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_UI">
<em class="property">class </em><tt class="descname">FilterNode_UI</tt><big>(</big><em>settings=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_UI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="classmethod">
<dt id="Red9.core.Red9_CoreUtils.FilterNode_UI.show">
<em class="property">classmethod </em><tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode_UI.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.FilterNode">
<em class="property">class </em><tt class="descname">FilterNode</tt><big>(</big><em>roots=None</em>, <em>filterSettings=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>FilterNode is a class for managing, searching and filtering nodes with the scene.
If the arg roots[] is given then the code filters the hierarchy&#8217;s of these roots.
If roots is not given then the functions will search globally at a scene level.</p>
<p>Note that the main call, ProcessFilter() is only part of this class, there are 
many other specific filtering functions for finding nodes in your Maya scene.</p>
<p>This is a crucial class and used extensively in Red9 where ever hierarchies
are in need of filtering. Used in conjunction with a FilterNode_Settings object 
which,if not given, gets bound to self.settings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span> <span class="o">=</span> <span class="n">FilterNode</span><span class="p">(</span><span class="n">rootNode</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">nodeTypes</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;nurbsCurve&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">searchPattern</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Ctrl&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">ProcessFilter</span><span class="p">()</span>
</pre></div>
</div>
<p>The above makes a filterNode class, we pass in our hierarchies rootNode (string), 
then set the internal settings to filter the hierarchy for all child nurbsCurves 
who&#8217;s name includes &#8216;Ctrl&#8217;. Finally the ProcessFilter runs the main call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>roots</strong> &#8211; Given root nodes in the Maya scene to search from.
If a root is NOT given then the filter codes default to scanning all scene nodes.</li>
<li><strong>filterSettings</strong> &#8211; This expects a FilterNode_Settings Object to be passed in. This
in turn holds all the filtering parameters used by the main lsIntersector call
all other calls use given params so can be called directly.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.rootNodes">
<tt class="descname">rootNodes</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.rootNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.processMode">
<tt class="descname">processMode</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.processMode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.knownShapes">
<em class="property">static </em><tt class="descname">knownShapes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.knownShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.getObjectSetMembers">
<tt class="descname">getObjectSetMembers</tt><big>(</big><em>objSet</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.getObjectSetMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>return objectSet members in long form</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsHierarchy">
<tt class="descname">lsHierarchy</tt><big>(</big><em>incRoots=False</em>, <em>transformClamp=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsHierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple wrapper of the listRelatives, BUT with the option
to include the rootNodes and select the results</p>
<p>Also if a single rootNode is passed, and it&#8217;s of type &#8216;character&#8217;
then the code will return the characterMembers instead
:param incRoots: include the given rootNodes in the filter
TODO: objectSet modifications need testing!!!!!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsSearchNodeTypes">
<tt class="descname">lsSearchNodeTypes</tt><big>(</big><em>nodeTypes</em>, <em>nodes=None</em>, <em>incRoots=True</em>, <em>transformClamp=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsSearchNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Main filter function wraps the cmds.listRelatives but replicates
the mel listTransforms function in that it&#8217;s capable of just returning
the transform nodes of the given nodeTypes
for example, when filtered for meshes, we might not want the shape node
This now has complex handling for dealing with CharcterSets and SelectionSets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodeTypes</strong> &#8211; Maya NodeTypes passed into the listRelatives wrapper</li>
<li><strong>nodes</strong> &#8211; optional - allows you to pass in a list to process if required</li>
<li><strong>incRoots</strong> &#8211; Include the given root nodes in the search, default=True
Valid only if the Class is in &#8216;Selected&#8217; processMode only.</li>
<li><strong>transformClamp</strong> &#8211; Clamp the return to the Transform nodes. Ie, mesh normally
would return the shape node, this clamps the return to it&#8217;s Transform node, default=False</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of nodes who type match the given search list</p>
</td>
</tr>
</tbody>
</table>
<p>TODO: Add the ability to use the NOT: operator in this, so for example, nodeTypes=transform
would return all mesh nodes too, or rather the transform from a mesh, maybe you&#8217;d want to
clamp that and prevent mesh transforms being returned? Is this even reasonable???</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsMeshes">
<tt class="descname">lsMeshes</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsMeshes" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for Meshes : from a start node find all mesh nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsTransforms">
<tt class="descname">lsTransforms</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsTransforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for Transforms : from a start node find all transform nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsJoints">
<tt class="descname">lsJoints</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsJoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for Joints : from a start node find all Joints nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsLocators">
<tt class="descname">lsLocators</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsLocators" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for Locators : from a start node find all Locators nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsIkData">
<tt class="descname">lsIkData</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsIkData" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for IKData : from a start node find all ikHandle &amp; ikEffector nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsNurbsCurve">
<tt class="descname">lsNurbsCurve</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsNurbsCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for NurbsCurve : from a start node find all NurbsCurve nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsConstraintsAll">
<tt class="descname">lsConstraintsAll</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsConstraintsAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for All Constraint Nodes : from a start node find all Constraint nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsOrientConstraint">
<tt class="descname">lsOrientConstraint</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsOrientConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for OrientConstraint : from a start node find all OrientConstraint nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsPointConstraint">
<tt class="descname">lsPointConstraint</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsPointConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for PointConstraint : from a start node find all PointConstraint nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsParentConstraint">
<tt class="descname">lsParentConstraint</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsParentConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter for ParentConstraint : from a start node find all ParentConstraint nodes in the hierarchy</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsAnimCurves">
<em class="property">static </em><tt class="descname">lsAnimCurves</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsAnimCurves" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for animationCurves. If no nodes are passed in to process then this
is a simple one liner, BUT if you pass in a selection of nodes to process
then it&#8217;s a lot harder. This code has to traverse the history and connection
lists to find any animCurves that are in the nodes graph. This passes over
character sets and animLayers to find all animCurve data.
Note that this has no filter for excluding curves of type
eg: setDrivens etc will need post filtering from the returns in many cases</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; optional given node list, return animData in the nodes history</li>
<li><strong>safe</strong> &#8211; optional &#8216;bool&#8217;, only return animCurves which are safe to modify, this
will strip out SetDrivens, Clips curves etc..</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsSearchAttributes">
<tt class="descname">lsSearchAttributes</tt><big>(</big><em>searchAttrs</em>, <em>nodes=None</em>, <em>incRoots=True</em>, <em>returnValues=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsSearchAttributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for nodes that have a given attr or any attrs from a given list[]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>searchAttrs</strong> &#8211; list or string of attributes to search for on all child nodes
NOTE: new operators &#8216;NOT:&#8217; and &#8216;=&#8217;</li>
<li><strong>nodes</strong> &#8211; optional - allows you to pass in a list to process if required</li>
<li><strong>returnValues</strong> &#8211; If found return the Value of the Attrs
along with the node - switches return type to tuple. default=False</li>
<li><strong>incRoots</strong> &#8211; Include the given root nodes in the search, default=True
Valid only if the Class is in &#8216;Selected&#8217; processMode only.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">list[] or dict{} of nodes whos attributes include any of the given attrs[]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nodes that have the search attr/attrs. If returnValue is given as a
keyword then it will return a dict in the form {node,attrValue}</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the searchAttrs has an entry in the form NOT:searchAttr then this will be forcibly
excluded from the filter. Also you can now do &#8216;myAttr=2.33&#8217; to only pass if the attr is equal
similarly &#8216;NOT:myAttr=2.33&#8217; will exclude if the value is equal
see the ..Red9     estsRed9_CoreUtilTests.py for live unittest examples</p>
</div>
<dl class="docutils">
<dt>TODO: current Implementation DOES NOT allow multiple attr tests as only 1 val per key </dt>
<dd>in the excludeAttrs and includeAttrs is currently supported!!!!!!</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsSearchNamePattern">
<tt class="descname">lsSearchNamePattern</tt><big>(</big><em>searchPattern</em>, <em>nodes=None</em>, <em>incRoots=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsSearchNamePattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for nodes who&#8217;s name match the given search patterns</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>searchPattern</strong> &#8211; string/list patterns to match node names against (includes a &#8216;NOT:&#8217; operator)</li>
<li><strong>nodes</strong> &#8211; optional - allows you to pass in a list to process if required</li>
<li><strong>incRoots</strong> &#8211; Include the given root nodes in the search, default=True
Valid only if the Class is in &#8216;Selected&#8217; processMode only.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the searchPattern has an entry in the form NOT:searchtext then this will be forcibly
excluded from the filter. ie, My_L_Foot_Ctrl will be excluded with the following pattern
[&#8216;Ctrl&#8217;,&#8217;NOT:My&#8217;] where Ctrl finds it, but the &#8216;NOT:My&#8217; tells the filter to skip it if found</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsCharacterSets">
<tt class="descname">lsCharacterSets</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsCharacterSets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get any characterSets from the given rootNode (single only). If rootNode[0]
is of type &#8216;character&#8217; then it will just return itself. If not will test
all children of the root for links to characterSets and return those found.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsCharacterMembers">
<tt class="descname">lsCharacterMembers</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsCharacterMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>From self.characterSets return all it&#8217;s node members. If characterSets attr
hasn&#8217;t been set then it will invoke a test on the RootNode down through
it&#8217;s hierarchy to find all characterSet links. Not that this now processes
subCharacterSets too</p>
<p>##### THIS NEEDS WORK TO RETURN THE MEMBERS IN THE CORRECT ORDER #####</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.lsMetaRigControllers">
<tt class="descname">lsMetaRigControllers</tt><big>(</big><em>walk=True</em>, <em>incMain=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.lsMetaRigControllers" title="Permalink to this definition">¶</a></dt>
<dd><p>very light wrapper to handle MetaData in the FilterSystems. This is hard coded
to find CTRL markered attrs and give back the attached nodes
:param walk: walk the found systems for subSystems and process those too
:param incMain: Like the other filters we allow the given top</p>
<blockquote>
node in the hierarchy to be removed from processing. In a MetaRig
this is the CTRL_Main controller which should be Top World Space</blockquote>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.ProcessFilter">
<tt class="descname">ProcessFilter</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.ProcessFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the &#8216;P&#8217; in the function call but not depricating it just yet
as too much code both internally and externally relies on this method</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.FilterNode.processFilter">
<tt class="descname">processFilter</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.FilterNode.processFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses intersection to allow you to process multiple search flags for
more accurate filtering.
Uses the FilterNode_Settings object for all args such that:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>settings.nodeTypes</strong> &#8211; nodetypes to search for on child nodes</li>
<li><strong>settings.searchAttrs</strong> &#8211; attribute to search for on child nodes</li>
<li><strong>settings.searchPattern</strong> &#8211; name pattern to match on child nodes</li>
<li><strong>settings.transformClamp</strong> &#8211; Clamp the return to the Transform nodes.</li>
<li><strong>settings.incRoots</strong> &#8211; Include the given root nodes in the search.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">all nodes which match ALL the given keyword filter searches</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.getBlendTargetsFromMesh">
<tt class="descname">getBlendTargetsFromMesh</tt><big>(</big><em>node</em>, <em>asList=True</em>, <em>returnAll=False</em>, <em>levels=4</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.getBlendTargetsFromMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>quick func to return the blendshape targets found from a give mesh&#8217;s connected blendshape&#8217;s</p>
<p>TODO: missing index&#8217;s used to be an issue if you&#8217;d deleted a target Maya would leave the 
index free resulting in blank targets, doesn&#8217;t seem to do that now?? Also what do we 
return and in what format if we have multiple blendShapes on the node?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; node to inspect for blendShapes, or the blendshape itself</li>
<li><strong>asList</strong> &#8211; return as a straight list of target names or a dict of data</li>
<li><strong>returnAll</strong> &#8211; if multiple blendshapes are found do we return all, or just the first</li>
<li><strong>levels</strong> &#8211; same as the &#8216;levels&#8217; flag in listHistory as that&#8217;s ultimately what grabs the blendShape nodes here</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.getBlendTargetIndex">
<tt class="descname">getBlendTargetIndex</tt><big>(</big><em>blendNode</em>, <em>targetName</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.getBlendTargetIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>given a blendshape node return the weight index for a given targetName</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>blendNode</strong> &#8211; blendShape node to inspect</li>
<li><strong>targetName</strong> &#8211; target Alias Name of the channel we&#8217;re trying to find the index for</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.matchNodeLists">
<tt class="descname">matchNodeLists</tt><big>(</big><em>nodeListA</em>, <em>nodeListB</em>, <em>matchMethod='stripPrefix'</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.matchNodeLists" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches 2 given NODE LISTS by node name via various methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>matchMethod</strong> &#8211; <p>default &#8216;stripPrefix&#8217; 
<em>index</em>: No intelligent matching, just purely zip the 
lists together in the order they were given</p>
<p><em>base</em>:  Match each element by exact name (shortName) 
such that Spine==Spine or REF1:Spine==REF2:Spine</p>
<p><em>stripPrefix</em>: Match each element by a relaxed naming convention 
allowing for prefixes one side such that RigX_Spine == Spine</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">matched pairs of tuples for processing [(a1,b2),[(a2,b2)]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.processMatchedNodes">
<tt class="descname">processMatchedNodes</tt><big>(</big><em>nodes=None</em>, <em>filterSettings=None</em>, <em>toMany=False</em>, <em>matchMethod='stripPrefix'</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.processMatchedNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>HUGELY IMPORTANT CALL FOR ALL ANIMATION FUNCTIONS</p>
<p>PreProcess the given &#8216;nodes&#8217; and &#8216;filterSettings&#8217;(optional)
via a MatchedNodeInput OBJECT that has an attribute self.MatchedPairs
We&#8217;re going to use this throughout the code such that:
nodeList.MatchedPairs = [(ObjA,ObjB),(ObjC,ObjD) .....]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; Given Nodes for processing</li>
<li><strong>filterSettings</strong> &#8211; as all other functions, this is the main hierarchy filter</li>
<li><strong>toMany</strong> &#8211; Return a MatchedPairs where the first node in each
tuple is the first selected node, ie, used to cast data from the first
node to all subsequent nodes [(ObjA,ObjB),(ObjA,ObjC),(ObjA,ObjD) ....</li>
<li><strong>matchMethod</strong> &#8211; method used in the name matchProcess</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MatchNodeInputs class object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.MatchedNodeInputs">
<em class="property">class </em><tt class="descname">MatchedNodeInputs</tt><big>(</big><em>nodes=None</em>, <em>filterSettings=None</em>, <em>matchMethod='stripPrefix'</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatchedNodeInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to process and match input nodes for most of the Hierarchy/Anim
functions that work on carefully managed matched pairs of nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; root nodes to start the filtering process from</li>
<li><strong>matchMethod</strong> &#8211; Method of matching each nodePair based on nodeName</li>
<li><strong>filterSettings</strong> &#8211; <p>This is a FilterSettings_Node object used to pass all 
the filter types into the FilterNode code within. Internally the following 
is true:</p>
<div class="line-block">
<div class="line">settings.nodeTypes: list[] - search nodes of type</div>
<div class="line">settings.searchAttrs: list[] - search nodes with Attrs of name</div>
<div class="line">settings.searchPattern: list[] - search for a given nodeName searchPattern</div>
<div class="line">settings.hierarchy: bool - process all children from the roots</div>
<div class="line">settings.incRoots: bool - include the original root nodes in the filter</div>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of matched pairs [(a1,b2),[(a2,b2)]</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">with all the search and hierarchy keywords OFF the code performs
a Dumb zip, no matching and no Hierarchy filtering, just zip the given nodes
into selected pairs obj[0]&gt;obj[1], obj[2]&gt;obj[3] etc</p>
</div>
<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.MatchedNodeInputs.processMatchedPairs">
<tt class="descname">processMatchedPairs</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatchedNodeInputs.processMatchedPairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter selected roots for hierarchy matching using a FilterNode and it&#8217;s
settings object if one was passed in to the main class.
This uses the ProcessFilter() method for powerful pre-filtering before
passing the results into the matchNodeLists func.
:rtype: tuple
:return: a matched pair list of nodes</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.LockChannels">
<em class="property">class </em><tt class="descname">LockChannels</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple UI to manage the lock and key status of nodes</p>
<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.LockChannels.UI">
<em class="property">class </em><tt class="descname">UI</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels.UI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="classmethod">
<dt id="Red9.core.Red9_CoreUtils.LockChannels.UI.show">
<em class="property">classmethod </em><tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels.UI.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.LockChannels.saveChannelMap">
<tt class="descclassname">LockChannels.</tt><tt class="descname">saveChannelMap</tt><big>(</big><em>filepath=None</em>, <em>nodes=None</em>, <em>hierarchy=True</em>, <em>serializeNode=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels.saveChannelMap" title="Permalink to this definition">¶</a></dt>
<dd><p>WE HAVE TO LOCK THE ATTRIBUTE!! why, 32k Maya string character Limits kick in and
truncates the data unless the attr is locked out</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.LockChannels.loadChannelMap">
<tt class="descclassname">LockChannels.</tt><tt class="descname">loadChannelMap</tt><big>(</big><em>filepath=None</em>, <em>nodes=None</em>, <em>hierarchy=True</em>, <em>serializeNode=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels.loadChannelMap" title="Permalink to this definition">¶</a></dt>
<dd><p>From a given chnMap file restore the channelBox status for all attributes
found that are in the map file. ie, keyable, hidden, locked</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here we&#8217;re dealing with 2 possible sets of data, either decoded by the
ConfigObj decoder or a JSON deserializer and there&#8217;s subtle differences in the dict
thats returned hence the decodeString() calls</p>
</div>
<p>TODO: Add progress bar?</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.LockChannels.processState">
<em class="property">static </em><tt class="descclassname">LockChannels.</tt><tt class="descname">processState</tt><big>(</big><em>nodes</em>, <em>attrs</em>, <em>mode</em>, <em>hierarchy=False</em>, <em>userDefined=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.LockChannels.processState" title="Permalink to this definition">¶</a></dt>
<dd><p>Easy wrapper to manage channels that are keyable / locked
in the channelBox.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; nodes to process</li>
<li><strong>attrs</strong> &#8211; set() of attrs</li>
<li><strong>mode</strong> &#8211; &#8216;lock&#8217;, &#8216;unlock&#8217;, &#8216;hide&#8217;, &#8216;unhide&#8217;, &#8216;fullkey&#8217;, &#8216;lockall&#8217;</li>
<li><strong>hierarchy</strong> &#8211; process all child nodes, default is now False</li>
<li><strong>usedDefined</strong> &#8211; process all UserDefined attributes on all nodes</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r9Core</span><span class="o">.</span><span class="n">LockChannels</span><span class="o">.</span><span class="n">processState</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;sx&quot;</span><span class="p">,</span> <span class="s">&quot;sy&quot;</span><span class="p">,</span> <span class="s">&quot;sz&quot;</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;lockall&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.timeOffset_addPadding">
<tt class="descname">timeOffset_addPadding</tt><big>(</big><em>pad=None</em>, <em>padfrom=None</em>, <em>scene=False</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.timeOffset_addPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrap of the timeoffset class which will add padding into the
animation curves on the selected object by shifting keys
:param pad: amount of padding frames to add
:param padfrom: frame to pad from</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.timeOffset_collapse">
<tt class="descname">timeOffset_collapse</tt><big>(</big><em>scene=False</em>, <em>timerange=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.timeOffset_collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Light wrap over the TimeOffset call to manage collapsing time</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.timeOffset_collapseUI">
<tt class="descname">timeOffset_collapseUI</tt><big>(</big><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.timeOffset_collapseUI" title="Permalink to this definition">¶</a></dt>
<dd><p>collapse time confirmation UI</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset">
<em class="property">class </em><tt class="descname">TimeOffset</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class for dealing with time manipulation inside Maya.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">=</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#build a filterSettings object up, in this case we&#39;re loading a current one.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span><span class="o">=</span><span class="n">r9Core</span><span class="o">.</span><span class="n">FilterNode_Settings</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">r9Setup</span><span class="o">.</span><span class="n">red9Presets</span><span class="p">(),</span><span class="s">&#39;Crytek_New_Meta.cfg&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span><span class="o">.</span><span class="n">incRoots</span><span class="o">=</span><span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flt</span><span class="o">.</span><span class="n">printSettings</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r9Core</span><span class="o">.</span><span class="n">TimeOffset</span><span class="p">()</span><span class="o">.</span><span class="n">fromSelected</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">filterSettings</span><span class="o">=</span><span class="n">flt</span><span class="p">,</span> <span class="n">flocking</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.fullScene">
<em class="property">classmethod </em><tt class="descname">fullScene</tt><big>(</big><em>offset</em>, <em>timelines=False</em>, <em>timerange=None</em>, <em>ripple=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.fullScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the entire scene and time offset all suitable nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; number of frames to offset</li>
<li><strong>timelines</strong> &#8211; offset the playback timelines</li>
<li><strong>timerange</strong> &#8211; only offset times within a given timerange</li>
<li><strong>ripple</strong> &#8211; manage the upper range of data and ripple them with the offset</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.fromSelected">
<em class="property">classmethod </em><tt class="descname">fromSelected</tt><big>(</big><em>offset</em>, <em>nodes=None</em>, <em>filterSettings=None</em>, <em>flocking=False</em>, <em>randomize=False</em>, <em>timerange=None</em>, <em>ripple=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.fromSelected" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the current selection list and offset as appropriate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; number of frames to offset</li>
<li><strong>nodes</strong> &#8211; nodes to offset (or root of the filterSettings)</li>
<li><strong>flocking</strong> &#8211; wether to sucessively increment nodes during offset</li>
<li><strong>randomize</strong> &#8211; whether to add a ramdon factor to each succesive nodes offset</li>
<li><strong>timerange</strong> &#8211; only offset times within a given timerange</li>
<li><strong>ripple</strong> &#8211; manage the upper range of data and ripple them with the offset</li>
<li><strong>filterSettings</strong> &#8211; <p>this is a FilterSettings_Node object used to pass all 
the filter types into the FilterNode code. Internally the following is true:</p>
<div class="line-block">
<div class="line">settings.nodeTypes: list[] - search nodes of type</div>
<div class="line">settings.searchAttrs: list[] - search nodes with Attrs of name</div>
<div class="line">settings.searchPattern: list[] - search for a given nodeName searchPattern</div>
<div class="line">settings.hierarchy: bool - process all children from the roots</div>
<div class="line">settings.incRoots: bool - include the original root nodes in the filter</div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.animCurves">
<em class="property">static </em><tt class="descname">animCurves</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.animCurves" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift Animation curves. If nodes are fed in to process then we do
a number of aggressive searches to find all linked animation data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; amount to offset the curves</li>
<li><strong>nodes</strong> &#8211; nodes to offset if given</li>
<li><strong>timerange</strong> &#8211; if timerange given [start,end] then we cut the keys in that 
range before shifting associated keys. Now we could just use the 
keyframe(option=&#8217;insert&#8217;) BUT this has a MAJOR crash bug!</li>
<li><strong>ripple</strong> &#8211; manage the upper range of keys and ripple them with the offset</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.timelines">
<em class="property">static </em><tt class="descname">timelines</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.timelines" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the main playback timelines and CurrentFrame</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.sound">
<em class="property">static </em><tt class="descname">sound</tt><big>(</big><em>offset</em>, <em>mode='Scene'</em>, <em>audioNodes=None</em>, <em>timerange=None</em>, <em>ripple=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.sound" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset Audio nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; amount to offset the sounds nodes by</li>
<li><strong>mode</strong> &#8211; either process entire scene or selected</li>
<li><strong>audioNodes</strong> &#8211; optional, given nodes to process</li>
<li><strong>timerange</strong> &#8211; optional timerange to process (outer bounds only)</li>
<li><strong>ripple</strong> &#8211; when shifting nodes ripple the offset to sounds after the range, 
if ripple=False we only shift audio that starts in tghe bounds of the timerange</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.animClips">
<em class="property">static </em><tt class="descname">animClips</tt><big>(</big><em>offset</em>, <em>mode='Scene'</em>, <em>clips=None</em>, <em>timerange=None</em>, <em>ripple=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.animClips" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset Trax Clips</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; amount to offset the sounds nodes by</li>
<li><strong>mode</strong> &#8211; either process entire scene or selected</li>
<li><strong>clips</strong> &#8211; optional, given clips to offset</li>
<li><strong>timerange</strong> &#8211; optional timerange to process (outer bounds only)</li>
<li><strong>ripple</strong> &#8211; when shifting nodes ripple the offset to clips after the range, 
if ripple=False we only shift clips that starts in tghe bounds of the timerange</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.TimeOffset.metaNodes">
<em class="property">static </em><tt class="descname">metaNodes</tt><big>(</big><em>*args</em>, <em>**kws</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.TimeOffset.metaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset special handling for MetaNodes. Inspect the metaNode and see if 
the &#8216;timeOffset&#8217; method has been implemented and if so, call it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; amount to offset the sounds nodes by</li>
<li><strong>timerange</strong> &#8211; optional timerange to process (outer bounds only)</li>
<li><strong>ripple</strong> &#8211; when shifting nodes ripple the offset to clips after the range, 
if ripple=False we only shift clips that starts in tghe bounds of the timerange</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.floatIsEqual">
<tt class="descname">floatIsEqual</tt><big>(</big><em>a</em>, <em>b</em>, <em>tolerance=0.01</em>, <em>allowGimbal=True</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.floatIsEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>compare 2 floats with tolerance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; value 1</li>
<li><strong>b</strong> &#8211; value 2</li>
<li><strong>tolerance</strong> &#8211; compare with this tolerance default=0.001</li>
<li><strong>allowGimbal</strong> &#8211; allow values differences to be divisible by 180 compensate for gimbal flips</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.valueToMappedRange">
<tt class="descname">valueToMappedRange</tt><big>(</big><em>value</em>, <em>currentMin</em>, <em>currentMax</em>, <em>givenMin</em>, <em>givenMax</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.valueToMappedRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts like the setRange node but code side
we have a min max range, lets say 0.5 - 15 and we want to map the
range to a new range say 0-1 and return where the value given is
in that new range</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_CoreUtils.distanceBetween">
<tt class="descname">distanceBetween</tt><big>(</big><em>nodeA</em>, <em>nodeB</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.distanceBetween" title="Permalink to this definition">¶</a></dt>
<dd><p>simple calculation to return the distance between 2 objects</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_CoreUtils.MatrixOffset">
<em class="property">class </em><tt class="descname">MatrixOffset</tt><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatrixOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Given 2 transforms calculate the difference as a Matrix and
apply that as an offset matrix to a given list of nodes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">matrixOffset</span> <span class="o">=</span> <span class="n">MatrixOffset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrixOffset</span><span class="o">.</span><span class="n">setOffsetMatrix</span><span class="p">(</span><span class="s">&#39;inputA&#39;</span><span class="p">,</span><span class="s">&#39;inputB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">applyOffsetMatrixToNodes</span><span class="p">(</span><span class="n">nodesToOffset</span><span class="p">)</span>
</pre></div>
</div>
<dl class="staticmethod">
<dt id="Red9.core.Red9_CoreUtils.MatrixOffset.get_MDagPath">
<em class="property">static </em><tt class="descname">get_MDagPath</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatrixOffset.get_MDagPath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.MatrixOffset.setOffsetMatrix">
<tt class="descname">setOffsetMatrix</tt><big>(</big><em>inputA</em>, <em>inputB</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatrixOffset.setOffsetMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>from 2 transform return an offsetMatrix between them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputA</strong> &#8211; MayaNode A</li>
<li><strong>inputB</strong> &#8211; MayaNode B</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_CoreUtils.MatrixOffset.applyOffsetMatrixToNodes">
<tt class="descname">applyOffsetMatrixToNodes</tt><big>(</big><em>nodes</em>, <em>matrix=None</em><big>)</big><a class="headerlink" href="#Red9.core.Red9_CoreUtils.MatrixOffset.applyOffsetMatrixToNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>offset all the given nodes by the given MMatrix object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; Nodes to apply the offset Matrix too</li>
<li><strong>matrix</strong> &#8211; Optional OpenMaya.MMatrix to transform the data by</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="Red9_Audio.html"
                        title="previous chapter">Red9_Audio</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Red9_General.html"
                        title="next chapter">Red9_General</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/red9templates/Red9_Core.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Red9_General.html" title="Red9_General"
             >next</a> |</li>
        <li class="right" >
          <a href="Red9_Audio.html" title="Red9_Audio"
             >previous</a> |</li>
        <li><a href="../index.html">Red9 v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Mark Jackson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
    </div>
  </body>
</html>